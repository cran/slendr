<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>Tree-sequence processing and statistics</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Tree-sequence processing and
statistics</h1>



<p>In this vignette, we will show how to specify sampling events to
record individuals in the tree-sequence output file (a procedure which
is called “remembering” of individuals in the SLiM context) and how to
perform simple analyses using <em>slendr</em>’s interface to the <a href="https://tskit.dev"><em>tskit</em></a> Python library. We will
demonstrate these features on a simulation of Neanderthal introgression
into anatomically modern humans. Specifically, we will show how to
estimate the amount of Neanderthal ancestry using <span class="math inline">\(f\)</span>-statistics calculated directly on the
tree-sequence data structure generated by a <em>slendr</em> model, all
entirely from R.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">library</span>(slendr)</span></code></pre></div>
<div id="setting-up-python-environment" class="section level2">
<h2>Setting up Python environment</h2>
<p>First, in order to be able to interface with <em>tskit</em> and
<em>pyslim</em> using the <em>reticulate</em> package (and run
simulations using <code>msprime</code>, as we do below), we will need a
working Python environment with the required Python modules
<code>pyslim</code>, <code>tskit</code> and <code>msprime</code> already
installed.</p>
<p>Because setting up Python environments can be quite a <a href="https://xkcd.com/1987/">hassle</a>, <em>slendr</em> provides a
single function <code>setup_env()</code> to make things easier. If you
call it without any arguments, <em>slendr</em> will automatically
download, install, and setup a <strong>completely separate</strong>
Python environment (based on the “miniconda” distribution) just for
<em>slendr</em> and activate it in the background.</p>
<p>It is important to stress that <code>setup_env()</code> will not
interfere in any way with any of the Python installations you might
already have on your computer. The Python installation and environment
will be entirely isolated and used just for the purpose of
<em>slendr</em> workflows.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="fu">setup_env</span>()</span></code></pre></div>
<p>Once we have the Python environment set up, we can activate it by
calling:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="fu">init_env</span>()</span></code></pre></div>
<pre><code>#&gt; The interface to all required Python modules has been activated.</code></pre>
<p>We can use another built-in function <code>check_env()</code> to make
sure that <em>slendr</em> installed and configured the correct
environment for us:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="fu">check_env</span>()</span></code></pre></div>
<pre><code>#&gt; Summary of the currently active Python environment:
#&gt; 
#&gt; Python binary: /Users/mp/Library/r-miniconda-arm64/envs/Python-3.12_msprime-1.3.3_tskit-0.5.8_pyslim-1.0.4_tspop-0.0.2/bin/python 
#&gt; Python version: 3.12.7 | packaged by conda-forge | (main, Oct  4 2024, 15:57:01) [Clang 17.0.6 ] 
#&gt; 
#&gt; slendr requirements:
#&gt;  - tskit: version 0.5.8 ✓ 
#&gt;  - msprime: version  ✓ 
#&gt;  - pyslim: version 1.0.4 ✓ 
#&gt;  - tspop: present ✓</code></pre>
<p>Now we’re good to go and ready to simulate and analyse tree sequence
outputs in R!</p>
<div id="model-of-neanderthal-introgression-into-eurasians" class="section level3">
<h3>Model of Neanderthal introgression into Eurasians</h3>
<p>First, let’s set up a simple <em>non-spatial</em> model of
Neanderthal introgression using <em>slendr.</em> This is essentially the
same procedure which we have shown in another vignette introducing <a href="vignette-04-nonspatial-models.html">non-spatial <em>slendr</em>
models</a>. This is no different from a spatial model, except that we
left out the <code>map</code> argument in calling
<code>population()</code>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="fu">library</span>(ggplot2)</span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a><span class="fu">library</span>(dplyr)</span></code></pre></div>
<pre><code>#&gt; 
#&gt; Attaching package: &#39;dplyr&#39;</code></pre>
<pre><code>#&gt; The following objects are masked from &#39;package:stats&#39;:
#&gt; 
#&gt;     filter, lag</code></pre>
<pre><code>#&gt; The following objects are masked from &#39;package:base&#39;:
#&gt; 
#&gt;     intersect, setdiff, setequal, union</code></pre>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">314159</span>)</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a><span class="co"># create the ancestor of everyone and a chimpanzee outgroup</span></span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a><span class="co"># (we set both N = 1 to reduce the computational time for this model)</span></span>
<span id="cb11-5"><a href="#cb11-5" tabindex="-1"></a>chimp <span class="ot">&lt;-</span> <span class="fu">population</span>(<span class="st">&quot;CH&quot;</span>, <span class="at">time =</span> <span class="fl">6.5e6</span>, <span class="at">N =</span> <span class="dv">1000</span>)</span>
<span id="cb11-6"><a href="#cb11-6" tabindex="-1"></a></span>
<span id="cb11-7"><a href="#cb11-7" tabindex="-1"></a><span class="co"># two populations of anatomically modern humans: Africans and Europeans</span></span>
<span id="cb11-8"><a href="#cb11-8" tabindex="-1"></a>afr <span class="ot">&lt;-</span> <span class="fu">population</span>(<span class="st">&quot;AFR&quot;</span>, <span class="at">parent =</span> chimp, <span class="at">time =</span> <span class="fl">6e6</span>, <span class="at">N =</span> <span class="dv">10000</span>)</span>
<span id="cb11-9"><a href="#cb11-9" tabindex="-1"></a>eur <span class="ot">&lt;-</span> <span class="fu">population</span>(<span class="st">&quot;EUR&quot;</span>, <span class="at">parent =</span> afr, <span class="at">time =</span> <span class="fl">70e3</span>, <span class="at">N =</span> <span class="dv">5000</span>)</span>
<span id="cb11-10"><a href="#cb11-10" tabindex="-1"></a></span>
<span id="cb11-11"><a href="#cb11-11" tabindex="-1"></a><span class="co"># Neanderthal population splitting at 600 ky ago from modern humans</span></span>
<span id="cb11-12"><a href="#cb11-12" tabindex="-1"></a><span class="co"># (becomes extinct by 40 ky ago)</span></span>
<span id="cb11-13"><a href="#cb11-13" tabindex="-1"></a>nea <span class="ot">&lt;-</span> <span class="fu">population</span>(<span class="st">&quot;NEA&quot;</span>, <span class="at">parent =</span> afr, <span class="at">time =</span> <span class="fl">600e3</span>, <span class="at">N =</span> <span class="dv">1000</span>, <span class="at">remove =</span> <span class="fl">40e3</span>)</span>
<span id="cb11-14"><a href="#cb11-14" tabindex="-1"></a></span>
<span id="cb11-15"><a href="#cb11-15" tabindex="-1"></a><span class="co"># 3% Neanderthal introgression into Europeans between 55-50 ky ago</span></span>
<span id="cb11-16"><a href="#cb11-16" tabindex="-1"></a>gf <span class="ot">&lt;-</span> <span class="fu">gene_flow</span>(<span class="at">from =</span> nea, <span class="at">to =</span> eur, <span class="at">rate =</span> <span class="fl">0.03</span>, <span class="at">start =</span> <span class="dv">55000</span>, <span class="at">end =</span> <span class="dv">45000</span>)</span>
<span id="cb11-17"><a href="#cb11-17" tabindex="-1"></a></span>
<span id="cb11-18"><a href="#cb11-18" tabindex="-1"></a>model <span class="ot">&lt;-</span> <span class="fu">compile_model</span>(</span>
<span id="cb11-19"><a href="#cb11-19" tabindex="-1"></a>  <span class="at">populations =</span> <span class="fu">list</span>(chimp, nea, afr, eur), <span class="at">gene_flow =</span> gf,</span>
<span id="cb11-20"><a href="#cb11-20" tabindex="-1"></a>  <span class="at">generation_time =</span> <span class="dv">30</span>,</span>
<span id="cb11-21"><a href="#cb11-21" tabindex="-1"></a>  <span class="at">path =</span> <span class="fu">paste0</span>(<span class="fu">tempfile</span>(), <span class="st">&quot;_introgression&quot;</span>)</span>
<span id="cb11-22"><a href="#cb11-22" tabindex="-1"></a>)</span></code></pre></div>
<p>Here’s our toy model visualized as a “demographic graph” of sorts
(i.e., a tree-like structure specifying population splits with
additional edges representing gene flow events). Not particularly
illuminating in this simple example, but it’s always worth keeping in
mind that such graph is embedded within every <em>slendr</em> model and
can be always invoked to make sure the model you’re setting up is
correct:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a>cowplot<span class="sc">::</span><span class="fu">plot_grid</span>(</span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a>  <span class="fu">plot_model</span>(model, <span class="at">sizes =</span> <span class="cn">FALSE</span>),</span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a>  <span class="fu">plot_model</span>(model, <span class="at">sizes =</span> <span class="cn">FALSE</span>, <span class="at">log =</span> <span class="cn">TRUE</span>),</span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a>  <span class="at">nrow =</span> <span class="dv">1</span></span>
<span id="cb12-5"><a href="#cb12-5" tabindex="-1"></a>)</span></code></pre></div>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAeAAAADwCAYAAADYdbe6AAAEDmlDQ1BrQ0dDb2xvclNwYWNlR2VuZXJpY1JHQgAAOI2NVV1oHFUUPpu5syskzoPUpqaSDv41lLRsUtGE2uj+ZbNt3CyTbLRBkMns3Z1pJjPj/KRpKT4UQRDBqOCT4P9bwSchaqvtiy2itFCiBIMo+ND6R6HSFwnruTOzu5O4a73L3PnmnO9+595z7t4LkLgsW5beJQIsGq4t5dPis8fmxMQ6dMF90A190C0rjpUqlSYBG+PCv9rt7yDG3tf2t/f/Z+uuUEcBiN2F2Kw4yiLiZQD+FcWyXYAEQfvICddi+AnEO2ycIOISw7UAVxieD/Cyz5mRMohfRSwoqoz+xNuIB+cj9loEB3Pw2448NaitKSLLRck2q5pOI9O9g/t/tkXda8Tbg0+PszB9FN8DuPaXKnKW4YcQn1Xk3HSIry5ps8UQ/2W5aQnxIwBdu7yFcgrxPsRjVXu8HOh0qao30cArp9SZZxDfg3h1wTzKxu5E/LUxX5wKdX5SnAzmDx4A4OIqLbB69yMesE1pKojLjVdoNsfyiPi45hZmAn3uLWdpOtfQOaVmikEs7ovj8hFWpz7EV6mel0L9Xy23FMYlPYZenAx0yDB1/PX6dledmQjikjkXCxqMJS9WtfFCyH9XtSekEF+2dH+P4tzITduTygGfv58a5VCTH5PtXD7EFZiNyUDBhHnsFTBgE0SQIA9pfFtgo6cKGuhooeilaKH41eDs38Ip+f4At1Rq/sjr6NEwQqb/I/DQqsLvaFUjvAx+eWirddAJZnAj1DFJL0mSg/gcIpPkMBkhoyCSJ8lTZIxk0TpKDjXHliJzZPO50dR5ASNSnzeLvIvod0HG/mdkmOC0z8VKnzcQ2M/Yz2vKldduXjp9bleLu0ZWn7vWc+l0JGcaai10yNrUnXLP/8Jf59ewX+c3Wgz+B34Df+vbVrc16zTMVgp9um9bxEfzPU5kPqUtVWxhs6OiWTVW+gIfywB9uXi7CGcGW/zk98k/kmvJ95IfJn/j3uQ+4c5zn3Kfcd+AyF3gLnJfcl9xH3OfR2rUee80a+6vo7EK5mmXUdyfQlrYLTwoZIU9wsPCZEtP6BWGhAlhL3p2N6sTjRdduwbHsG9kq32sgBepc+xurLPW4T9URpYGJ3ym4+8zA05u44QjST8ZIoVtu3qE7fWmdn5LPdqvgcZz8Ww8BWJ8X3w0PhQ/wnCDGd+LvlHs8dRy6bLLDuKMaZ20tZrqisPJ5ONiCq8yKhYM5cCgKOu66Lsc0aYOtZdo5QCwezI4wm9J/v0X23mlZXOfBjj8Jzv3WrY5D+CsA9D7aMs2gGfjve8ArD6mePZSeCfEYt8CONWDw8FXTxrPqx/r9Vt4biXeANh8vV7/+/16ffMD1N8AuKD/A/8leAvFY9bLAAAAOGVYSWZNTQAqAAAACAABh2kABAAAAAEAAAAaAAAAAAACoAIABAAAAAEAAAHgoAMABAAAAAEAAADwAAAAAA4jJ20AADKMSURBVHgB7d0HYBRV/gfw7+6mdwgBQi8hoUhH4EAgCodgBOQU5QTL2c47PT0r9+dU9Ox4eqeHHByeisKpWMCCgig1KCUEBOkkSEsoSSCkl939z+8luwkppOwuO9n9Pt3slDdvZj6zy2/fzJt5BquWwEQBClCAAhSgwCUVMF7StXFlFKAABShAAQooAQZgfhAoQAEKUIACbhBgAHYDOldJAQpQgAIU0H0Afu+991BaWsojRQEKNEEBfn+b4EHjJl8yAYPeG2F1794dycnJCAoKumQoXBEFKOAcAX5/nePIUjxTQPc1YM9k515RgAIUoIC3CzAAe/sngPtPAQpQgAJuEWAAdgs7V0oBClCAAt4uwADs7Z8A7j8FKEABCrhFwMcta+VKKdDEBfLz83HD2F+jWWEhro6LrffebD1xAl1Hj8Gfn3yq3sswo2cIZGRkYNmyZejdu3ejd0geXOjj44NBgwY1ugwuCOjl+8sAzE8jBRohsHXrVlzpY8IfenVv0NK/6dgef1y5EmAAbpBbU8+clZWF0dcMQbPux9DiqANP/zUAPy0Nw8J5X2LYsGFNncVt26+X7y8DsNs+AlxxUxZo1qwZekSEX7ALOSUl8DMa4W8yodhsRl6pGc38/VBisUDmNff3V/mHd+lywXIc8XyBM2fOIG64FS0HOBB8y5lMU7KRevQAA7ADHxu9fH8ZgB04iFyUAjaB/0tKxtr0k1rgteD33WPRJTQEr/68B99cPQZbz2RA5q9LGGfLzncvE/D19UVA8IVNbjZ+YEaXQUZEdzOgpMiKjR9Y7CrdhhpxLt2KM0es0H7TIbyVAZeNNsDkY4BBG29W5ceffUEONErAXd9fBuBGHS4u5G0C1uJiwFrxD6S1uEgbL1M4nJOLlcdPIGnStTiWl4f1J0+pGVLzPVNQiHOybOWklWMtKqw8Bdq/rDBo1/aYvEPgxD4r9qy14myaBdc+YoJZ+4js22BFwkNlQTq8JbDzWysiWgNtuxuw+VML/AKN6DFSOwetpTM5qTiamewdWM7Yy+IS+/dViks/fRAWa9kTFt35/eU33hkHl2V4vED+E3+B9VRZYJWdLTh7FijUgnBEGDaeOo3LtFPSRoMBHUNCcEtMCL47kYY9585h6tr16vRzoHZa2pbMKSnIu+dO26h69x3za/jfcvsF0zjS9AXSzv6MjNzDOJ52EkXmfPsO7V1nwdAbjdjymXZ5IsMKX+3qhPy+O76n7Fdda61WLClP+5hlHIVWQ9Y+atFl02T6suTHkVRYFqxlnOniAo9uHI8WBaH2TOHa9zejUPvVEwG3fn8ZgO2HhAMUaJzAyNat8NLOXSjUrvvuzDqLxYdSMaFDO/Rt3lydgv5BC9ByiovJ+wQSDy7A+v1zkX3aipwCK6JgRFG+FYe2WOGnPV03IATYowXjvmON6tRyi45lQdZY/nvN5Asc3m5Bp34Gdaq6qmCgbzgu73Jz1ckcryIQuFX7JVNQcQar8mx3fn8ZgCsfCQ5ToJ4CZktFY5oOIcG4NaYrrvjqG3UNePbggfUshdm8UeDAj1ZEx5YF1Ajt2m7ycgt6/7rsWm+3IRfWatv2MGDIDUZ8+H9mtL/Mor0unB8SEIUbB7/hjYwN2ue8Tx6GNbviDJZevr8MwA06jMxMgTKBA+fPY8PJ04iP1i7SaenxPpfh4ct6wkdazJSnMW3bqKFhrVpe0ABLTk0zea+Av1bzHTbViKjy2q5ZuxRZUgAMnFjx2RGdmCEGNG9rQFCYAVffb1Knqr1Xzbl7rpfvLwOwc48rS/MSgRs6dURyZhZe/GkX2jagp645e/fhxUEDvESJu2kTKNYu/yZ9YVENquR0sqRi7ZS0pF5Xlo33HlMxTaZ37FORL6oTENXJoE5fH95mRWiU5GBqrIBevr8MwI09glzOqwUMWoOrxgTSW7t19Wo3b915CZ5Drjdi+zcWhEWVBdbGWJz5xSoN5jHwVxfWlhtTljcvo5fvLwOwN38Kue8UoMAlE+jYx6jVah1c3SgHl+fiuhLgzyhdHQ5uDAUoQAEKeIsAA7C3HGnuJwUoQAEK6EqAAVhXh4MbQwEKUIAC3iLAAOwtR5r7SQEKUIACuhJgIyxdHY7aN6ZE601n6q0TkHJ8B/qP0h4U28hkNluxd0Mxvl6aiKgo3svQSEYuRgEKUMBhAQZghwkvTQF79+5Fjs8eXHFPprZCeTU+tYUFSz75H+77w4ONL4RLUoACFKCAQwJOCcDS2bTVakVkZGS9NiY3NxdpaWmIjY215z98+DDat28PH/YIYzepPBCiPeS/dUe/ypO07ssa151ZQIjWaUCn9heUxREKUIACFLi0Ag5fA/7666/x3XffYcGCBTh48GCNW5+fn4/jx4+reRkZGZg9ezaSk5OxaNEiFbhffvllHDp0CM8//3yNy3NidQFbd2bbtKfrSLJ1Z9Z1kAHyku7Mju6yQh57J0/eOfCDRXtVPL9YbkRnogAFKEAB9wk4XAPetm0brrnmGvTp0wedOnXC7t27sWHDBsg/8NOnT0dwcDBOnz6NTZs2YerUqdi8eTMmT56M/v3745lnnsH+/fvRsmVLSIfV9913n11i+fLlSE1NVQHaPtELB0rMhSjVomthcY7Wf2VFbx6Odmf2zvrp+D5L62pFSwzGdX+wHsgZhUgE152ROShAAQrUU8DhAHzgwAEMGzYMiYmJGDVqFJYuXYqEhAQcOXIE69atU6eUZd4prS/V7OxsyKnUuLg4++bJNKkNX3bZZXjttdfwwgsvqHnNtP5Vo6Oj7fm8dWDpthn27syy8rQOup3UnVmptVDruacYJqMfokJivJW33vttNDr8Van3upixuoCcRZMf+23alHVwUT1H/aac0zrCGDiQvVXVT4u5XC3g8L8qgwYNwujRo9UXQwJpQUEBjFqPMBI8Q0ND0bdvX3Wt11YDXrFiBTIzMxETEwOT1km5BGMp4/LLL8fq1auRk5OjlpOgLumJJ55wtUGTK9+Z3Zk1D+6AJyb+1OQMLvUG5yVq3ZnlVnRndqnX783ry8vLw6/Gj8fZFlFoNmiwQxTZa77HU3f8Dnf+9rcOlcOFKeAMAYcD8NChQ/Hf//5X1XjvvfdetGrVCklJSZBrvdOmTVPb2LZtW1UrlpERI0Zgzpw56jT18OHDERERAbPWkblcQ/b391fB1xk75sllsDszTz663LeqAnJZK1cLvCVXjcHpqjMbOG7t0QPvf/QBA3AD3ZjdNQIOB+AhQ4aoUzpSm5VriXKKKD4+XtVubdcW5fquvCTJNeEZM2agtLTU3uL5jjvugNznasvjml1t2qXma13IbvnMgi4DjYit0hNK/2vK2tINnHDhPlbu3Fs69tau9qoM589YYS65MC/HKKBXATmT5qu1E5FUeuwoCr7/DiG3/Q6WzAwUrl+HwPEJyH3nLfvm+3TqgqBrEmDRLm/lLn4PwTdOhUmrPauktUNs3/sye14OUMCdAg4HYNn4qrcOVR2vaQer5mHwrUmpYlp0rAFxw4344UMzIlo3vgVzVpoVp1OtSHjIVFE4hyjQRATM2pm1/E8/hkm7xOUbG4eiTT8icPQYFKz+HhFPzFJ7YQwPV+8F2unmwnVrYQyPQMi0W+x7KG0ZSywVDRrtM1wwYNFuz2SiQG0CTgnAtRXO6c4VsNV0nVsqS6OAPgVySkqRVVKME1q7Eu0Bbvbk07ET8ha/j7CHH7NP006poWjDejXuP3gI0LkLClatRNj9DyLnrf8geOrNMGhn6SR9kX4S7b/+Vg27+k+//KOIcfVKWH6TFWAAbrKHjhtOAc8W+ODYcTy1Z5867WwuLoZ/+e6aotvAf9hw5L77Ngx+5Q+n0R7gEzAqXuUwtWqN4n17YdbuvCg9chjWwgIUJW1FwJCh1cCGNG9WbZozJ0SYA4AiZ5bIsjxJgAHYk44m94UCXiIQPOVGFK5dUxGAtVO95qyyR7RatfYkhRsTERh/FXw6dELgmLEo+ObragFYLuR8PkyrLbswLdnSCuvPu3AFLLpJCzAAN+nDx42ngBcIWCrOP8u134ARI2Hw9UP4o49rNdxfYPAPQPD1U2DWHm8ryRpZBB/tsbYBWgA2ac8T8Bt0OfK/WAardrcFEwX0JMAArKejwW2hAAWqCZjPnEL+V1/Bf+Ag+LSOVi/JJI2w5CUp5Obp6r2mP8agIIRo14AlWbQHepjTywJ1TXk5jQKXUoAB+FJqc10UoECDBfy1e4BLtevBOQvmq9bPDS6gfAGpAect+QiRr73e2CK4HAWcKsAA7FROFkYBCrhCIHjyb5xSbPCkyU4ph4VQwBkCDveG5IyNYBkUoAAFKEABbxNgAPa2I879pQAFKEABXQgwAOviMHAjKEABClDA2wQYgL3tiHN/KUABClBAFwIMwLo4DNwIClCAAhTwNgEGYG874txfClCAAhTQhQADsC4OAzeCAhSgAAW8TYAB2NuOOPeXAlUErNpzlNPKH+NYZVaNo7m5uThw4IB93smTJ5GSkoLDhw/bp3GAAhSoW4AP4qjbiDko4LECRUVFePPNNxGkPa7x3nvvrXE/87XHN2ZlZaFdu3bI0PrjfeONN9CzZ09s2bIF06dPV+P9+vWD9OnduXPnGsvgRM8Q+OyzpcjOykGHDh0bvUMGgwFWYylGj76q0WV4yoIMwJ5yJLkfFGiEgNRkhwwZgl27dqmld+/ejQ0bNkD+kZTgGhwcjNOnT2PTpk2YOnUqNm/ejMmTJ6N///545plntG54S2HWHvEoAVzKsaXz589DgrvUrpk8Q+C7VavxyuMLMKHTg8gPCG30ThlgwIcHn0He7HxMnHRto8vxhAUZgD3hKHIfKNBIgd69e6sAawvAS5YsQUJCAo4cOYJ169bBR+tnNzExEae0vnWzs7MREhKCuLiyDhBklVI7HjBgALp3747Zs2fjpZdegknr+H7evHmqhtzIzeJiOhTISsvBHb3+jo4RPR3eutt8XkZWerLD5TT1AhiAm/oR5PZTwIkCBQUFMBqNiNa6/QsNDUXfvn0RGxtrrwGvWLECmZmZiImJUYHWYrFATj/LeKtWrSA132ZaF4CPP/642ioJzEyeIeDn56+dGSlrNrT8wHykZO2w79idA17GRz+/hN/0fAgRAVF4b8csJMTei83Hv8ShrO0wGXzQJiwGE+L+CB+jL6zaf+FhEfblvXWAAdhbjzz3mwI1CIwdOxZJSUnqWu+0adNUjrZt26pasYyMGDECc+bMUaephw8froL03Llz0bJlSxW0JfgyXToBczGQuefSrC+3Ui+OSSdWokN4D/RtfaVauZ8pAN+nvo9x3e5UAXjN4f9hZKcbkZS2Eu3C4tCn1Sgs3PEkgnzDcHXM7y7NBjeBtTAAN4GDxE2kgCsFJHjaGmCNGTMG8fHxqnYr14ElSeMqeUmSa8IzZsxQ137l9LSkmTNnXjCuJl7iP3Kt2Xz0CAxhYTA1a36J1+6+1RWdBba9fGnWf+QE0CqkYl17MzYhu+gMgv0iMKDNmIoZVYYy8o8j5ewOFJbmqWBsm332IHAiEQjQfrNF9rJN9a53BmDvOt7cWwrUKWALrBfLWDVP1fGLLeuKedmvzkbJgf2watepI557CX7durliNbor0zcY6DzBtZt1chNQcKb6OnpGDUO/6KtwruC0mim1YLOlVA3Lu6/R3z5907EvMbhdAnq1HGYvKH0DsDtVC769GYDtKBygAAUo0JQEJPAW/7QD1nPn1GZnz34BAcOugEFrDKa1IgOMJm1Yu3Yp49rLYJJpRhh8TFiYeUrV7qXhmNTy5YeEvF9sXPLYXrZlahqXa+muTr5ajbTbda5dy/lfag7AucVnkZmfhu3p3+PHY5+jRVB7fLx7NmIjL0du8TlEBkarDZPT1Lf3ew73fNkbA6PHXrS27No90V/prAHr75hwiyhAgQYIGAKDYPDz05r1lCWDBMguXQGzVhvTbpGylpoBi/auDavx4nxYtcZjMnzw4EF1+lxup5JXSUmJQ+O2MuTWLGmgVmTORrFWG5S2S9rvgLKXNmywDZsM8lugbFzylP02UPlqX0b9ftCWMSA0MBOvprx60R8Mjv6gyC300U4f++BM3jEtyLZVyKM63YRj5/chLecQWgZ3gL9PgPYwlh3aeyDSc1LxwpgVCNCq55KvY3hPRAS2xBMjl+BU7i/lR4lvIsAAzM8BBSjQpAV82rdH6B13I/d/i+DbLRah9/wexiDt3GwdSa5wP3ftuDpyOTb7fxvvx7q987SAr34DyO+Aspc2bq00LNPVeHk+q8VakVfmlf1eqLaMv69RBV8J+IWFhRf8eLD9GLD9uGjMuCxzPr0EJYVmnCs8DYu1VGtIFQ6j9gvCpP1akNbNJm3YWD6878wmHM/ehym9HlWnpvu2ileAcppaGm3JK6vgJDb88jEiy4O5Y8JNe2kG4KZ9/Lj1FPBYgVYB/hgYUc9bVRK0BzrIqwHJWNbGrAFLNDyrj692atu/MSuq3zJRoc3w5+v+3PANa8AS2/6utbTWntNi0X4FLNv7umrJbNQCr0X7xWB7Sc12y4mvEa7dgjS03URsS19V6xpOnD+gnRkowNSut9Wax1tmMAB7y5HmflKgiQlMahMNeTHpQ8ConROX+3yrpm8PvYufTq7B9L6zMKLj9VVnc/wiAgzAF8HhLApQgAIUuLhAVHB7/H3ceviZylo9Xzw351YWYACurMFhClCAAhRokED/6NENys/MFQJauzsmClCAAhSgAAUutQAD8KUW5/ooQAEKUIACmgADMD8GFKAABShAATcIMAC7AZ2rpAAFKEABCjAA8zNAAQpQgAIUcIMAA7Ab0LlKClCAAhSgAAMwPwMUoAAFKEABNwgwALsBnaukAAUoQAEKMADzM0ABClCAAhRwgwADsBvQuUoKUIACFKAAAzA/AxSgAAUoQAE3CDAAuwGdq6QABShAAQowAPMzQAEKUIACFHCDAAOwG9C5SgpQgAIUoAADMD8DFKAABShAATcIMAC7AZ2rpAAFKEABCjAA8zNAAQpQgAIUcIMAA7Ab0LlKClCAAhSgAAMwPwMUoAAFKEABNwgwALsBnaukAAUoQAEKMADzM0ABClCAAhRwgwADsBvQuUoKUIACFKAAAzA/AxSgAAUoQAE3CPi4YZ1cJQUo4GKBr776ComJiTh06BA6deqEgQMHYsKECQgJCXHxmlk8BShQXwEG4PpKMR8FmoDAli1b8Pbbb6Nbt2649tprER0djbS0NOzZswe33XYbJk2ahFtvvbUJ7Ak3kQKeL8AA7PnHmHvoRQKBgYH497//DYPBYN/rrl27YsSIEfj9738PCdBMFKCAPgQYgPVxHLgVFHCKQO/evVU5hYWFWLp0KX766SeMGTMGXbp0Ua/Bgwc7ZT0shAIUcFzAaY2wjh49Wu+tyc3NxYEDBy7If/jwYZSWll4wjSMUoEDjBF5//XVkZmZi37596jT0vffe27iCuBQFKOAyAacE4O3bt+PZZ5+tdSPz8/Nx/PhxNT8jIwOzZ89GcnIyFi1aBKvVipdfflk1Fnn++edrLYMzKECB+gvI9+v++++Hv78/evXqhdatW0NqxUwUoIB+BBwOwFKbldaW7dq1U3u1e/duzJs3D/Pnz0deXp6advr0aZVHRjZv3ozJkydj6tSpSElJwf79+9GyZUv4+vrivvvuU/nlzyeffAIJyBKgmShAgYYJyDXfmTNnqlrw3Llz1fcoICCgYYUwNwUo4FIBhwPwu+++q1pV2hp9LFmyBAMGDEDz5s2xbt06fPvtt6pV5po1a1RQPnfuHEJDQ+07lZ2drWrDwcHBeO211+zTY2JiMGjQIPs4ByhAgfoLyCnnUaNGoWfPnpCGWXPmzKn/wsxJAQpcEgGHGmGdP38e6enpWLBgAfbu3YsNGzagoKAARqNRXXeSQNu3b1/ExsZi06ZNqta7YsUK9atcAqzJZEJcXJwKtJdffjlWr16NnJwcFaD79eunAGyB/ZJocCUUaOIC8j37+eef7XvRp08fmM1mfPzxx7jrrrvs0zlAAQq4X8ChABwWFqZOE8tu/O1vf1O3OhQVFSEpKQlyrXfatGlqD9u2bYuEhAQ1LKfG5Ne4BOvhw4cjIiJC/QMhQVyuV1WuHasF+IcCFKi3gATbkpKSeudnRgpQwH0CDgXgypv91FNPqVG55SE+Pl7Vbm21V7m+Ky9Jcqp5xowZqsWzj0/Z6u+44w71j4Ytj8rIPxSgQIMF5EetvJgoQAH9CzgtAFfeVVtgrTyt6nDVPAy+VYU4ToHGC5w8eVI1ZJSWz9KQUS4VVW5j0fiSuSQFKOAsAYcbYTlrQ1gOBSjgPAFphCV3IcjDOCQI224DdN4aWBIFKOCoAAOwo4JcngI6FJBar1zqkWdBP/nkk4iMjIS0z2CiAAX0I8AArJ9jwS2hgNME5MEbn332mbrH/oMPPlD33MvdCUwUoIB+BPiN1M+x4JZQwGkCr7zyCuSe+1mzZqlrwXJKmu0snMbLgijgFAEGYKcwshAK6EvgpZdeUteAW7Vqpe6/l1owEwUooC8BBmB9HQ9uDQWcIiCPhP3Tn/6kypoyZQrkMZS8BuwUWhZCAacJuOQ2JKdtHQuiAAUaJdCjRw88+uijuOaaa9RT6qRRljzohokCFNCPAGvA+jkW3BIKOE3ghRdeUI95/fTTTyFPrHvzzTedVjYLogAFnCPAGrBzHFkKBXQlIC2e7777bvUQDul7W55Ax0QBCuhLgAFYX8eDW0MBpwhIjVf64ZZALLcjRUVFYdmyZU4pm4VQgALOEeApaOc4shQK6EpAugF97LHHIK2fly9fjvDwcEjf3UwUoIB+BGqtAcvj6+Qxdj/99BOkg4UuXbqol342nVtCAQrUJiA130WLFqmar63b0JCQkNqyczoFKOAGgVprwK+//rrqt3ffvn3qcXZyIz8TBSjQNATkQRzy3ZVT0bt27cJzzz3XNDacW0kBLxKotQacnJyMjz76SPXb26tXL8ij7aRWLPcTMlGAAvoWiImJsQddOXvFRAEK6E+g1hrwiBEjMHPmTFULnjt3rmpNyeCrvwPILaKAowJyj3BaWlq9i5FrydKy2pZKSkpw6NAhWCwW2yS+U4AC9RCotQYsp5ylIcfZs2dVS8qXX365HsUxCwUooAeB999/H0eOHLFvivx47tq1KyZMmIDKfXHL07HkNHVQUBBqu8wkramzsrLQrl07ZGRk4I033kDPnj2xZcsW9ZjLp59+GqNGjcLixYvVs6ftK+UABShwUYFaa8Dz5s3DM888gz179qiWlL/97W8vWhBnUoAC+hFIT09XtdJu3bohJycH69evVw0qH3744Qs2UmqyQ4YMsU+TR1jKd3/+/PnqWdIy4/Tp00hMTFR5Nm/ejMmTJ6vAm5KSguLiYvzxj3/E2LFjUVBQAKkNS/r444/VKXCpXTNRgAI1C9RaA16xYgU2bdoEg8FQ85KcSgEK6FZg27Zt6oeztIa+6aabID+gpaZ6ww03XLDNvXv3VgFWGmpJWrJkCRISElTted26daq2LMH31KlTyM7OhrSkjouLs5chNWd5ye1OAwcOtPe4JIFfbn2SmjgTBShQs0CtAXjSpEl49tlnER8fD5PJpJYePnx4zaVwKgUooCuBFi1aQHpEGj9+PCQYN2/eHDt37qzzedBSi5WgHR0djdDQUPTt2xexsbHqx/jUqVMhP8wzMzMhjbxs/y4sXLgQzZo1w8SJE+0G/fr1U8P8AW8n4QAFqgnUegp669at2L59u+pLVFpDy4uJAhRoGgL//Oc/4efnh1dffVX1giS3IUnjqX/84x8X3QE5lZyUlIS1a9eqZ0hL5rZt26pasQxL40yZ9/e//x3yg1xqzl999RXk1PWLL75oP20teZkoQIGLC9RaA5ZrSF9++eXFl+ZcClBAlwJyLVZqpXl5eep+YLkOPGzYsBq3tWXLlvYGWPLQHdtZL1vt1dfX135qWZ4pPWPGDJSWltobc8n1XiYKUKDhArUGYDmFNH36dNVAQ76AkmprJdnw1XIJClDAlQLyIB05RTx79mzV+GratGnqnv76rLNyK+na8tcnT23LcjoFKFAmUGsAlpaRHTp0oBMFKNAEBeQSknTCIEkaREm3hHJ9NzAwsAnuDTeZAp4pUC0Ab9y4UT0/1mw2228p8Mxd515RwHMF5AzWX//6V1x33XWq8ZWcTmbw9dzjzT1rmgLVGmHJaStpBSmnmKQRR+VX09xFbjUFvE/giSeeUA/HeOutt9T12n/961/eh8A9poDOBarVgIcOHao2WW6+l/sBbUlaOsqj5iQ4M1GAAvoWkO+ptGiWFxMFKKBPgWoBODU1VT2aTu73GzdunNpqCbzSp6iMMwDr80ByqyggAvLwnJ9//rlGjLvuuqvG6ZxIAQq4R6BaAO7cuTPkIRzyDGjbjfUSdB955BH7bQfu2VSulQIUqEuAbTfqEuJ8CuhHoFoAlsYaI0eOVC/9bCa3hAIUqI/AsWPH1KWjmu5gkMtK8mhI+THNRAEKuF+gWgB2/yZxCyhAgcYKSG9H8rQr6c9b+vGWR0pKV4N79+5Vz2z+29/+1tiiuRwFKOBkAQZgJ4OyOAq4U0CeVCUtoM+dO6ceJSv99EpXgQ899BAiIyPduWlcNwUoUEWAAbgKCEcp4AkCERERuPLKK9XLE/aH+0ABTxTgPUWeeFS5TxSgAAUooHsB1oB1f4i4gRRouEBhYSGWLl2qngMtHSx06dJFvRpeEpegAAVcJcAasKtkWS4F3CggnTFIv7379u1TDbHYkYobDwZXTYFaBBiAa4HhZAo0ZQFpBX3//ffD399ftYZu3bo1pFbMRAEK6EeAAVg/x4JbQgGnCYwYMQIzZ85UteC5c+fCarUiICDAaeWzIApQwHEBXgN23JAlUEB3AnLK+fvvv0dubq7qBWnOnDm620ZuEAW8XYAB2Ns/Adx/jxSQ3syk8dUVV1zhkfvHnaKAJwgwAHvCUeQ+UKCKgNR45bGTlU87r1u3rkoujlKAAu4UYAB2pz7XTQEXCUhvZtIzkjzbnYkCFNCnAAOwPo8Lt4oCDglIj2bPPvss4uPjYTKZVFnDhw93qEwuTAEKOFeAAdi5niyNAroQ2Lp1K86cOYOMjAz79jAA2yk4QAFdCDAA6+IwcCMo4FyB9PR0fPnll84tlKVRgAJOFWAAdionC6OAPgT69euH6dOnY8iQIfD19VUbxadh6ePYcCsoYBNgALZJ8J0CHiQggbdDhw4etEfcFQp4ngADsOcdU+6RFwts3LgRUVFRMJvNKCkp8WIJ7joF9C/AR1Hq/xhxCylQbwFp8Ww0GnHw4EH4+fnZX3v37oXFYql3OcxIAQq4XoA1YNcbcw0UuGQCLVu2xJtvvgm5D3jcuHFqvRJ4V65cqQKwBGcmClBAHwIMwPo4DtwKCjhFoHPnzpB7gM+ePYuJEyeqMiXoPvLII5DHUzJRgAL6EeA3Uj/HgltCAYcF5MlXI0eOVC+HC2MBFKCASwV4PsqlvCycAhSgAAUoULMAA3DNLpxKAQpQgAIUcKkAA7BLeVk4BShAAQpQoGYBBuCaXTiVAhSgAAUo4FIBBmCX8rJwClCAAhSgQM0CDreCPnToEL799lvV8ffNN998QQfgNa8SWLhwIU6dOoUpU6ZAbptISkrC9u3b0aVLF4wePbq2xTidAhSgAAUo4DECDteA169fj3vuuQfdu3fHmjVrFMzOnTshvbHYUlpamnowgIxLN2ktWrTAAw88gEWLFqn7FaWMu+++G6WlpbZF+E4BClCAAhTwaAGHa8B33HGHAvrxxx8xfvx4LFiwAD179sQPP/yA+Ph4FBcXIzk5GampqapXFumfVHpqCQgIUE/mSUlJwenTp/HKK6+ga9euduz3338fu3fvhtVqtU/jAAUoQAEKUMBTBByuAUuAnDNnDvr06aMCr9R+d+3ahaKiIkhwlQfDt2/fHpGRkejYsaN6Tq3tmbTyZJ6QkBDVa8tjjz2mnl+bn5+vbAcPHmx/ko+nYHM/KEABClCAAjYBh2vA8+fPVwFWAnBubq4KsvIovKNHj6pabnR0tHoEXlBQEGJiYlRgTkxMRFhYGAIDAxEbG4vPP/8cEnizsrLUw+Nl4+Li4tQ2ypN9mChAAQpQgAKeJuBwAA4NDUVmZiaWL1+OAQMGqOvBq1atUqebExISlJfUguUlqVevXigoKMDq1atx5513qhqxNN5asmQJ5HQ2n1ermPiHAhSgAAU8XMDhADxt2rRqRNdff321aZUnDBo0CPKyJTlFffvtt9tG+U4BClCAAhTweAGHrwF7vBB3kAIUoAAFKOACAQZgF6CySApQgAIUoEBdAgzAdQlxPgUoQAEKUMAFAgzALkBlkRSgAAUoQIG6BBiA6xLifApQgAIUoIALBBiAXYDKIilAAQpQgAJ1CTAA1yXE+RSgAAUoQAEXCDAAuwCVRVKAAhSgAAXqEmAArkuI8ylAAQpQgAIuEGAAdgEqi6QABShAAQrUJcAAXJcQ51OAAhSgAAVcIMAA7AJUFkkBClCAAhSoS4ABuC4hzqcABShAAQq4QIAB2AWoLJICFKAABShQlwADcF1CnE8BClCAAhRwgQADsAtQWSQFmqJAYmIikpOT69z0hQsXYvbs2Th8+LA97+LFi5GRkWEf5wAFKFC3AANw3UbMQQGPF/jmm2/wySefIDs7276vO3fuRHp6un1cBrZu3YoWLVrggQcewKJFi9S8BQsWYO3atSguLrbnleHCwkJYrVb7NA5QgAIXCvhcOMoxClDAGwVGjx6NkJAQlJaWqt2XoNqzZ0/88MMPiI+PR/fu3dX01NRU9OvXDwEBAbBYLGrabbfdVo3sxRdfxMaNG6tN5wQKUKBCgAG4woJDFPBaAT8/vwv2XWq/ZrMZRUVFSElJwaeffqqCswRiW+D18Sn756PqslLQrFmzVHm2wH1B4RyhAAWUAAMwPwgUoEA1gY4dO2LSpEk4evSoqu0mJCSoPLt374ZcKw4LC0NgYGC15TiBAhSovwADcP2tmJMCHi0gQVdqvZLuuecerFq1Cr6+vrAFX5neq1cvFBQUYPXq1bjzzjtlkkoDBw5EaGiobZTvFKBAPQQYgOuBxCwU8AaBDh062HdTarjXX3+9fbzywKBBgyCvymnAgAGVRzlMAQrUQ4CtoOuBxCwUoAAFKEABZwswADtblOVRgAIUoAAF6iHAAFwPJGahAAUoQAEKOFuAAdjZoiyPAhSgAAUoUA8BBuB6IDELBShAAQpQwNkCDMDOFmV5FKAABShAgXoIMADXA4lZKEABClCAAs4WYAB2tijLowAFKEABCtRDgAG4HkjMQgEKUIACFHC2AAOws0VZHgUoQAEKUKAeAgzA9UBiFgpQgAIUoICzBRiAnS3K8ihAAQpQgAL1EGAArgcSs1CAAhSgAAWcLeA1vSH9/PPPeHvxYvxqxAiHDDNOnMBdt9+uumlzqCAuTAEKUIACXi3gFQE4NTUVV99yC/InXIeFqUccOuDWn3Zgxdq1+FwL5kwUoAAFKECBxgp4RQAuLCxE8A03wty3f2Od7MtZ27aF76aN9nEOUIACFKAABRoj4BUB2GAwwGAyKZ/SY0dR8P13CLntd7BkZqBw/ToEjk9A7jtv2f18OnVB0DUJsGRnI3fxewi+cSpMLaLK5luBQK2zciYKUIACFKCAIwJeEYArA5kzMpD/6ccwRUfDNzYORZt+RODoMShY/T0inpilshrDw9V7wZrvUbhuLYzhEQiZdou9mJMFhVhx8pR93JUDR/PzXVk8y6YABShAATcJeHQA3nM+B5uyspCmNZzKN5vtxD4dOyFv8fsIe/gx+zSUlqJow3o17j94CNC5CwpWrUTY/Q8i563/IHjqzfZa9Oasc7g9aXvFsi4c6pd/BjEuLJ9FU4ACFKCAewQ8OgAnZmTiqT37IKedzaVm+Jcbm6LbwH/YcOS++zYMfn5lU318EDAqXg2bWrVG8b69MJ86hdIjh2EtLEBR0lYEDBlaXkLF21+7x1aMuGDo1OEInDvpgoJZJAUoQAEKuFXAowPwxWSDp9yIwrVrKgKw1QpzVqZaxFpSgsKNiQiMvwo+HTohcMxYFHzzdbUAbNBy/ymmy8VW4/C8JVnhWM8A7LAjC6AABSigNwGvCMASUC25ucperv0GjBgJg68fwh99XKvh/gKDfwCCr58Cc1qaymONLIJP+/YI0AKwqVkz+A26HPlfLIPVdhpba9TFRAEKUIACFHBEwCsCMLSAmf/5Uvh176EFXl/49uoFs9YC2hgZCT/tZcnLReDV46o7Wswqn8wI/PVYWM6dRcn+/TCfTK+el1MoQAEKUIACDRDwigDsqzWoCrn1dhT+uBGmyBYN4Lkwq7W4CEU/bET4jJkXzuAYBShAAQpQoIECXhGAxcS/X3/1aqBPteyBo39dbRonUIACFKAABRoqwM4YGirG/BSgAAUoQAEnCDAAOwGRRVCAAhSgAAUaKsAA3FAx5qcABShAAQo4QYAB2AmILIICFKAABSjQUAEG4IaKMT8FKEABClDACQJe0wraCVYswgkC8+YuQNbJ84iL6d7o0qR3q7CWgRhz9ZWNLoMLUoACFHC3AAOwu4+AF63/s08+x9J/JeLaLvcje2dZj1ON2X2DwYj5+5/Fqf87iWm3/LYxRXAZClCAAm4XYAB2+yHwng0wlvjjxriZaB8e5/BO3xirPQylaJfD5bAAClCAAu4SYAB2l7yXrtcKq9rz5QfmIyVrhxo+lXsEDw6dh68OzMNvej6EiIAovLdjFhJi78Xm41/iUNZ2mAw+aBMWgwlxf4SP0VcrxYqgoGAvVeRuU4ACniDAAFx+FHM//ghF69fBrD3vOfIfb8DUIsoTjm+d+1BaAKRtrDObUzKcO1hRTNKJlegQ3gN9W1+JfRmb8eTqBGTkn8DYmN+pALzm8P8wstONSEpbiXZhcejTahQW7ngSQb5huFrLw0QBClCgqQs4HIDTtB6ElixZgoCAANx9990wmUx1mixcuBCntL52p0yZgs6dO2PlypXYuXMnRowYgaFDq/e5W2eBDmYoOZyK/KWfwpqTo0o69/yzWk9IWgMfrbGP/Cf/q6R6QaoYl8ZA847/Uj5Tsmu5y18y0TYs75XH1chF5lfOvynlAA6mW2yLqG0pL05NqzZs29byJdT88mnqrdJ8mXeqOBfv/HdFWVmyt5UWUHuvjct/tpXZh7UJtvlqoy46Xrb43jP7EBl0HgUlOcgpOott6d/iaPYeBGpB9dZ+z+LF9VPx3Lob8Lv+L5QtUP43I/84Us7uQGFpngrGtplntAp0aggQ1ApoPcQ2le8UoAAFmoaAwwH4vffew4MPPogNGzYgMTERo0aNUsE0KioK0VrXf5IkSEuAHTduHLZu3YoWLVrgpptuwiuvvIL77rsP+/btwyOPPIKnn34agwcPhtHonLujBjWLwF/iutV5JNKsZrwVGoqz5QE4ND8PIyKbw6r1ESxnTG2nTbUJZdNsJWrjWVlZ9mmS3/aSLJWHK4+rcivNrzoueSXJ9MNpp3E6s+y0bdk0mSFD5W8Vs9QENWqbb5tnG7cvpBbXyteekW3IgU/Ap2qC2l7ZW5khSfbHtjI1WmX/yvPa8pe921Yqi5flzztlhdS0swrS4e8ThECfEJzI2a8F3lCcKzyN7KIMrEp5VwvoRmTlp2He1odgtpTC1+ivNsPPFIBNx77E4HYJ6NVymJomf84kA4dOAZG9GYDtKBygAAWajIDDAbi4uBiBgYHo1q0b1q9fjwMHDqBnz5744YcfEB8fD5mfnJyM1NRU+GpdAWZkZKBfv36qxmyxWHDs2DF07txZBd1IrWvA7OxsNNP64J0/f74K2rZ/3BsjOkALwPKqM3XripDtv8c777yDNm3a4MMPP0R7rT9gPaQ1e9/AjqNhLtuUZkHtcPuIBS4rXwre/yGQnQJs3LMCoXmdtFPP3fHMmt9oteE26BH1KxVs03NSsCN9tXadtxuu6jwN725/ApGBZT/g5DT17f2ewz1f9sbA6LEY0GaM2t7AlkBELBDSzqWbrwo3de4KS3g9PkuN3BRDy9aNXJKL6VkgKrQrura8wmWbKN9fVyf5fpmLXLcWb/7+OhyAbYdFgqm/vz+SkpJg1jquLyoqQkpKCgYMGKCCmQTWjh07qhqj5JXk4+OjTnnaxm1lyLzx48dj2LBh+O6772TU5empp56CvPSWruzxAOTVlFPc1LKt3/aPNBR9r0VNLY3qdBOOnd+HtJxD2HVqvXZqORZvXLMZG48txZm8Y3hhzAoE+AarfB3DeyJCi7ZPjFyCU7m/qOWNWm25ywQDBl+iu5AC/nCfWi//UKAhAp70/W3Ifustr16/vw4H4JCQEBw9elSdfu7fvz+OHz+OSZMmqWlyXVhOQ0ugDQoKQkxMjArMcqo6LCxM1Zyl9rts2TJ1/VeCtOST1KFDB/Vuux6qRvinSQtYfIqx6sh/EewXjrgWl6uX7NCgNldrDa/KAnN8p/JorU1Pz0lFbOQgtc8yHBXcXr2OZe/Hd0ffxrhC7dwzEwUoQIEmKmDQTvFWXLRrxE7k5+fj66+/RvPmzXHVVVfh/PnzWLVqlTrdnJCQUGOjLKkl7927FxMnTkR4eLg6PS3XkK+88kp74LVtSvfu3dUpbFtgtk3ne9MTkI/af/79NgKt4erz0dg9OHwkBQHhJjz02APljcYaWxKXc7UAv7+uFmb5TVnA4QDs6p3nF9jVwiyfAq4T4PfXdbYsuekLOKe5cdN34B5QgAIUoAAFLqmALgPwn//8Z8ydO/cCiLVr16rbmC6YyBEKUEB3Avz+6u6QcIN0KqDLAPzYY4+p25BOnjyp2EpLSzFr1iz85S9/0SkjN4sCFLAJ8Ptrk+A7BS4uYNIefvH0xbNc+rnSQload3311VfqVia5vamgoADyy5qJAhTQtwC/v/o+Ptw6/QjothFWYWEhRo4cqR5ZKV/oL774Qj2wQz903BIKUKA2AX5/a5PhdApUCOjyFLRsntxDPHPmTMhp6Ouuu47Bt+KYcYgCuhfg91f3h4gbqAMB3daAxUYeY7l8+XKMHj1aPbhDB17cBApQoJ4C/P7WE4rZvFZA1wHYa48Kd5wCFKAABTxeQLenoD1enjtIAQpQgAJeLcAA7NWHnztPAQpQgALuEmAAdpc810sBClCAAl4twADs1YefO08BClCAAu4SYAB2lzzXSwEKUIACXi3w/57uXrM+QbqPAAAAAElFTkSuQmCC" /><!-- --></p>
</div>
</div>
<div id="scheduling-of-sampling-events" class="section level2">
<h2>Scheduling of sampling events</h2>
<p>Now that we have defined a model, how do we sample data from it?
Ideally, we would like to to schedule sampling events at a given time,
sampling a defined number of individuals from a given population. This
is why <em>slendr</em> provides a function
<code>schedule_sampling()</code> which serves to define such sampling
schedule automatically and enforces that only populations which are
already (i.e. after their appearance in the simulation) or still (before
they are removed from the simulation) present will be sampled from.</p>
<p>In our example, we want to sample two Neanderthal individuals (the
older one being the Altai Neanderthal published by Pruefer <em>et
al.</em> 2014, the younger one Vindija Neanderthal published by Pruefer
<em>et al.</em>, 2017). These two genomes are what we need to estimate
Neanderthal ancestry proportion using a so-called <span class="math inline">\(f_4\)</span>-ratio statistic (more on that below,
but also see Petr <em>et al.</em>, PNAS 2019):</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a>nea_samples <span class="ot">&lt;-</span> <span class="fu">schedule_sampling</span>(model, <span class="at">times =</span> <span class="fu">c</span>(<span class="dv">70000</span>, <span class="dv">40000</span>), <span class="fu">list</span>(nea, <span class="dv">1</span>))</span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a>nea_samples</span></code></pre></div>
<pre><code>#&gt; # A tibble: 2 × 7
#&gt;    time pop       n y_orig x_orig y     x    
#&gt;   &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;lgl&gt;  &lt;lgl&gt;  &lt;lgl&gt; &lt;lgl&gt;
#&gt; 1 40000 NEA       1 NA     NA     NA    NA   
#&gt; 2 70000 NEA       1 NA     NA     NA    NA</code></pre>
<p>As you can see, the <code>schedule_sampling()</code> function simply
accepts the vector of times at which remembering should be schedule, and
then a list of pairs
<code>(&lt;slendr population&gt;, &lt;number of individuals&gt;)</code>
encoding from which populations should how many individuals be
remembered at time points given in the <code>times</code> vector.</p>
<p>Next, we want to sample some present-day individuals: an outgroup
representing a chimpanzee, and a couple of Africans and Europeans:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a>present_samples <span class="ot">&lt;-</span> <span class="fu">schedule_sampling</span>(model, <span class="at">times =</span> <span class="dv">0</span>, <span class="fu">list</span>(chimp, <span class="dv">1</span>), <span class="fu">list</span>(afr, <span class="dv">5</span>), <span class="fu">list</span>(eur, <span class="dv">10</span>))</span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a>present_samples</span></code></pre></div>
<pre><code>#&gt; # A tibble: 3 × 7
#&gt;    time pop       n y_orig x_orig y     x    
#&gt;   &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;lgl&gt;  &lt;lgl&gt;  &lt;lgl&gt; &lt;lgl&gt;
#&gt; 1     0 CH        1 NA     NA     NA    NA   
#&gt; 2     0 AFR       5 NA     NA     NA    NA   
#&gt; 3     0 EUR      10 NA     NA     NA    NA</code></pre>
<p>As you can see above, the <code>schedule_sampling()</code> function
returns a plain old data frame with a very simple structure with three
columns: time, population name, and the number of individuals. This
means that you can define sampling events using whatever input data you
might already have available (such as radiocarbon-dated ancient DNA
samples from an Excel sheet from some publication). For instance, there
has been a <a href="https://www.nature.com/articles/nature17993">lot</a>
of interest to estimate the trajectory of Neanderthal ancestry in Europe
over time using ancient DNA data from anatomically modern human
individuals (also called early modern humans, EMH) across the last
couple of tens of thousands of years. We can simulate something close to
the available <a href="https://www.nature.com/articles/nature17993">EMH
ancient DNA data set</a> over the last 50 thousand years by running
doing this:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a>emh_samples <span class="ot">&lt;-</span> <span class="fu">schedule_sampling</span>(model, <span class="at">times =</span> <span class="fu">runif</span>(<span class="at">n =</span> <span class="dv">40</span>, <span class="at">min =</span> <span class="dv">10000</span>, <span class="at">max =</span> <span class="dv">40000</span>), <span class="fu">list</span>(eur, <span class="dv">1</span>))</span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a>emh_samples</span></code></pre></div>
<pre><code>#&gt; # A tibble: 40 × 7
#&gt;     time pop       n y_orig x_orig y     x    
#&gt;    &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;lgl&gt;  &lt;lgl&gt;  &lt;lgl&gt; &lt;lgl&gt;
#&gt;  1 10320 EUR       1 NA     NA     NA    NA   
#&gt;  2 11188 EUR       1 NA     NA     NA    NA   
#&gt;  3 11396 EUR       1 NA     NA     NA    NA   
#&gt;  4 11529 EUR       1 NA     NA     NA    NA   
#&gt;  5 11927 EUR       1 NA     NA     NA    NA   
#&gt;  6 12675 EUR       1 NA     NA     NA    NA   
#&gt;  7 13689 EUR       1 NA     NA     NA    NA   
#&gt;  8 13744 EUR       1 NA     NA     NA    NA   
#&gt;  9 14775 EUR       1 NA     NA     NA    NA   
#&gt; 10 16362 EUR       1 NA     NA     NA    NA   
#&gt; # ℹ 30 more rows</code></pre>
<p>This samples a single ancient European individuals at randomly chosen
times between 40 and 10 ky ago.</p>
<p>One nice feature of the <code>schedule_sampling()</code> function is
that it only schedules sampling events for a population, if that
population is present in the simulation at a given time. This makes it
possible to simply take a wide time range for sampling, specify all
populations and sizes of the samples, and let the function generate
sampling events only for populations present at each time. If for some
reason a stricter control over sampling is required, this behavior can
be switched off by setting <code>strict = TRUE</code> like this:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a><span class="co"># this attempts to sample a Neanderthal individual at a point when Neanderthals</span></span>
<span id="cb19-2"><a href="#cb19-2" tabindex="-1"></a><span class="co"># are already extinct, resulting in an error</span></span>
<span id="cb19-3"><a href="#cb19-3" tabindex="-1"></a><span class="fu">schedule_sampling</span>(model, <span class="at">times =</span> <span class="dv">10000</span>, <span class="fu">list</span>(nea, <span class="dv">1</span>), <span class="at">strict =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<pre><code>Error: Cannot schedule sampling for &#39;NEA&#39; at time 10000 because the population will not be present in the simulation at that point. Consider running this function with `strict = FALSE` which will automatically retain only valid sampling events.</code></pre>
<p>Now that we already have the <code>model</code> object ready, we can
simulate data from it, sampling individuals according to our sampling
schedule. Although we could use the <code>slim()</code> function shown
in previous vignettes, in this case we will run the simulation with the
<code>msprime()</code> coalescent back end. After all, our model is
non-spatial and using a coalescent simulator will be much more efficient
than the forward simulation. Switching between the msprime and SLiM back
ends of slendr is demonstrated in much more detail in a <a href="https://www.slendr.net/articles/vignette-07-backends.html">dedicated
vignette</a>.</p>
<p>The simulation back end utilized by the <code>msprime()</code>
function (as well as the <code>slim()</code> function) produces a
tree-sequence output which is immediately loaded and ready for a
downstream analysis.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a>ts <span class="ot">&lt;-</span> <span class="fu">msprime</span>(</span>
<span id="cb21-2"><a href="#cb21-2" tabindex="-1"></a>  model, <span class="at">sequence_length =</span> <span class="fl">100e6</span>, <span class="at">recombination_rate =</span> <span class="fl">1e-8</span>,</span>
<span id="cb21-3"><a href="#cb21-3" tabindex="-1"></a>  <span class="at">samples =</span> <span class="fu">rbind</span>(nea_samples, present_samples, emh_samples),</span>
<span id="cb21-4"><a href="#cb21-4" tabindex="-1"></a>  <span class="at">random_seed =</span> <span class="dv">314159</span>, <span class="at">verbose =</span> <span class="cn">TRUE</span></span>
<span id="cb21-5"><a href="#cb21-5" tabindex="-1"></a>)</span>
<span id="cb21-6"><a href="#cb21-6" tabindex="-1"></a></span>
<span id="cb21-7"><a href="#cb21-7" tabindex="-1"></a>ts</span></code></pre></div>
<pre><code>#&gt; ╔═══════════════════════════╗
#&gt; ║TreeSequence               ║
#&gt; ╠═══════════════╤═══════════╣
#&gt; ║Trees          │     240041║
#&gt; ╟───────────────┼───────────╢
#&gt; ║Sequence Length│  100000000║
#&gt; ╟───────────────┼───────────╢
#&gt; ║Time Units     │generations║
#&gt; ╟───────────────┼───────────╢
#&gt; ║Sample Nodes   │        116║
#&gt; ╟───────────────┼───────────╢
#&gt; ║Total Size     │   40.0 MiB║
#&gt; ╚═══════════════╧═══════════╝
#&gt; ╔═══════════╤══════╤═════════╤════════════╗
#&gt; ║Table      │Rows  │Size     │Has Metadata║
#&gt; ╠═══════════╪══════╪═════════╪════════════╣
#&gt; ║Edges      │916588│ 28.0 MiB│          No║
#&gt; ╟───────────┼──────┼─────────┼────────────╢
#&gt; ║Individuals│    58│  1.6 KiB│          No║
#&gt; ╟───────────┼──────┼─────────┼────────────╢
#&gt; ║Migrations │     0│  8 Bytes│          No║
#&gt; ╟───────────┼──────┼─────────┼────────────╢
#&gt; ║Mutations  │     0│ 16 Bytes│          No║
#&gt; ╟───────────┼──────┼─────────┼────────────╢
#&gt; ║Nodes      │189654│  5.1 MiB│          No║
#&gt; ╟───────────┼──────┼─────────┼────────────╢
#&gt; ║Populations│     4│338 Bytes│         Yes║
#&gt; ╟───────────┼──────┼─────────┼────────────╢
#&gt; ║Provenances│     1│  7.1 KiB│          No║
#&gt; ╟───────────┼──────┼─────────┼────────────╢
#&gt; ║Sites      │     0│ 16 Bytes│          No║
#&gt; ╚═══════════╧══════╧═════════╧════════════╝</code></pre>
<p>Note that we bind the individual sampling schedule data frames using
the <code>rbind</code> function provided by base R (as we show above,
the sampling schedule really is just a data frame and we can manipulate
it as such).</p>
</div>
<div id="r-interface-for-tskit-and-pyslim" class="section level2">
<h2>R interface for <em>tskit</em> and <em>pyslim</em></h2>
<p>Tree-sequences are one of the most revolutionary developments in
population genetics in the last couple of decades for a number of
reasons. One of them is the possibility to store extremely large data
sets succinctly by encoding the entire evolutionary history of a sample
of individuals as a series of correlated tree genealogies along the
genome.</p>
<p>Going into too much detail on this topic is clearly beyond the scope
of this tutorial, especially because everything is explain much better
<a href="https://tskit.dev/learn/">elsewhere</a>. Instead, what we will
demonstrate in the rest of this vignette is how you can access and
manipulate tree-sequence outputs generated by <em>slendr</em> models and
perform various statistics on them using Python modules <a href="https://tskit.dev/tskit/docs/stable/"><em>tskit</em></a> and <a href="https://pyslim.readthedocs.io/en/latest/index.html"><em>pyslim</em></a>
directly from <em>slendr,</em> without having to leave R! The key is a
magical R package <a href="https://rstudio.github.io/reticulate/index.html"><em>reticulate</em></a>
which creates a seamless binding of Python modules with R. This means
that even if you don’t know Python, <em>slendr</em> allows you to do do
quite a lot with tree-sequences in R.</p>
<p>Of course, if you are a proficient Python user, it needs to be said
that once you have the tree-sequence file generated by <em>slendr</em>
&amp; SLiM, you can easily perform every conceivable analysis directly
using <em>tskit</em>. The intention here is to show how you can continue
working on the tree-sequence files in R even after you have run the
entire <em>slendr</em> simulation.</p>
</div>
<div id="loading-and-processing-tree-sequence-output-files" class="section level2">
<h2>Loading and processing tree-sequence output files</h2>
<p>By default, any <code>msprime()</code> or <code>slim()</code> run
will produce a tree-sequence object (saved to a temporary file) and
immediately load it. Thus, in most use-cases, explicit loading of a
simulated tree sequence is not needed. That said, for the sake of
completeness, let’s run the simulation again but save the tree-sequence
file ourselves.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a>output_file <span class="ot">&lt;-</span> <span class="fu">tempfile</span>()</span>
<span id="cb23-2"><a href="#cb23-2" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" tabindex="-1"></a>ts <span class="ot">&lt;-</span> <span class="fu">msprime</span>(</span>
<span id="cb23-4"><a href="#cb23-4" tabindex="-1"></a>  model, <span class="at">sequence_length =</span> <span class="fl">100e6</span>, <span class="at">recombination_rate =</span> <span class="fl">1e-8</span>,</span>
<span id="cb23-5"><a href="#cb23-5" tabindex="-1"></a>  <span class="at">samples =</span> <span class="fu">rbind</span>(nea_samples, present_samples, emh_samples),</span>
<span id="cb23-6"><a href="#cb23-6" tabindex="-1"></a>  <span class="at">random_seed =</span> <span class="dv">314159</span></span>
<span id="cb23-7"><a href="#cb23-7" tabindex="-1"></a>)</span>
<span id="cb23-8"><a href="#cb23-8" tabindex="-1"></a></span>
<span id="cb23-9"><a href="#cb23-9" tabindex="-1"></a><span class="fu">ts_write</span>(ts, output_file)</span>
<span id="cb23-10"><a href="#cb23-10" tabindex="-1"></a></span>
<span id="cb23-11"><a href="#cb23-11" tabindex="-1"></a>output_file</span></code></pre></div>
<pre><code>#&gt; [1] &quot;/var/folders/70/b_q2zdh116b9pfg29p03sx600000gn/T//RtmprRF8Bn/file148e225bb545&quot;</code></pre>
<p>In case have the tree-sequence output saved in a custom location on
disk, we can load the tree sequence using the <em>slendr</em> function
<code>ts_read()</code>. If we’re dealing with a tree sequence produced
by the SLiM back end (which is not the case here), we can also instruct
this function to simplify the tree-sequence to only the individuals that
we explicitly sampled (recall the sampling schedule we set up with the
<code>schedule_sampling()</code> function above). Note that we have to
provide the <code>model</code> object generated by
<code>compile_model()</code> above in order to have all model annotation
information for the simulated tree-sequence data (we have to do this
only once, and only during loading):</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" tabindex="-1"></a>ts <span class="ot">&lt;-</span> <span class="fu">ts_read</span>(output_file, model)</span>
<span id="cb25-2"><a href="#cb25-2" tabindex="-1"></a>ts</span></code></pre></div>
<pre><code>#&gt; ╔═══════════════════════════╗
#&gt; ║TreeSequence               ║
#&gt; ╠═══════════════╤═══════════╣
#&gt; ║Trees          │     240041║
#&gt; ╟───────────────┼───────────╢
#&gt; ║Sequence Length│  100000000║
#&gt; ╟───────────────┼───────────╢
#&gt; ║Time Units     │generations║
#&gt; ╟───────────────┼───────────╢
#&gt; ║Sample Nodes   │        116║
#&gt; ╟───────────────┼───────────╢
#&gt; ║Total Size     │   40.0 MiB║
#&gt; ╚═══════════════╧═══════════╝
#&gt; ╔═══════════╤══════╤═════════╤════════════╗
#&gt; ║Table      │Rows  │Size     │Has Metadata║
#&gt; ╠═══════════╪══════╪═════════╪════════════╣
#&gt; ║Edges      │916588│ 28.0 MiB│          No║
#&gt; ╟───────────┼──────┼─────────┼────────────╢
#&gt; ║Individuals│    58│  1.6 KiB│          No║
#&gt; ╟───────────┼──────┼─────────┼────────────╢
#&gt; ║Migrations │     0│  8 Bytes│          No║
#&gt; ╟───────────┼──────┼─────────┼────────────╢
#&gt; ║Mutations  │     0│ 16 Bytes│          No║
#&gt; ╟───────────┼──────┼─────────┼────────────╢
#&gt; ║Nodes      │189654│  5.1 MiB│          No║
#&gt; ╟───────────┼──────┼─────────┼────────────╢
#&gt; ║Populations│     4│338 Bytes│         Yes║
#&gt; ╟───────────┼──────┼─────────┼────────────╢
#&gt; ║Provenances│     1│  7.1 KiB│          No║
#&gt; ╟───────────┼──────┼─────────┼────────────╢
#&gt; ║Sites      │     0│ 16 Bytes│          No║
#&gt; ╚═══════════╧══════╧═════════╧════════════╝</code></pre>
<p>Not surprisingly, we get the same output which we got above when we
printed the tree sequence returned by the <code>msprime()</code>
function. This shows that under normal circumstances, loading the output
manually via <code>ts_read()</code> is not needed.</p>
<p>If we try to simplify an <em>msprime</em>-generated tree sequence, we
get a warning. This is because such tree sequence is already in a
simplified form, by definition coming from a coalescent simulator.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" tabindex="-1"></a><span class="fu">ts_simplify</span>(ts)</span></code></pre></div>
<pre><code>#&gt; ╔═══════════════════════════╗
#&gt; ║TreeSequence               ║
#&gt; ╠═══════════════╤═══════════╣
#&gt; ║Trees          │     238681║
#&gt; ╟───────────────┼───────────╢
#&gt; ║Sequence Length│  100000000║
#&gt; ╟───────────────┼───────────╢
#&gt; ║Time Units     │generations║
#&gt; ╟───────────────┼───────────╢
#&gt; ║Sample Nodes   │        116║
#&gt; ╟───────────────┼───────────╢
#&gt; ║Total Size     │   36.7 MiB║
#&gt; ╚═══════════════╧═══════════╝
#&gt; ╔═══════════╤══════╤═════════╤════════════╗
#&gt; ║Table      │Rows  │Size     │Has Metadata║
#&gt; ╠═══════════╪══════╪═════════╪════════════╣
#&gt; ║Edges      │864772│ 26.4 MiB│          No║
#&gt; ╟───────────┼──────┼─────────┼────────────╢
#&gt; ║Individuals│    58│  1.6 KiB│          No║
#&gt; ╟───────────┼──────┼─────────┼────────────╢
#&gt; ║Migrations │     0│  8 Bytes│          No║
#&gt; ╟───────────┼──────┼─────────┼────────────╢
#&gt; ║Mutations  │     0│ 16 Bytes│          No║
#&gt; ╟───────────┼──────┼─────────┼────────────╢
#&gt; ║Nodes      │139203│  3.7 MiB│          No║
#&gt; ╟───────────┼──────┼─────────┼────────────╢
#&gt; ║Populations│     4│338 Bytes│         Yes║
#&gt; ╟───────────┼──────┼─────────┼────────────╢
#&gt; ║Provenances│     2│  7.7 KiB│          No║
#&gt; ╟───────────┼──────┼─────────┼────────────╢
#&gt; ║Sites      │     0│ 16 Bytes│          No║
#&gt; ╚═══════════╧══════╧═════════╧════════════╝</code></pre>
<p>By default, simplification trims the tree sequence down to only
remembered individuals (i.e. those we explicitly scheduled for
sampling), which is true for every <em>msprime</em> tree sequence.
Alternatively, we can also narrow down the simplification to a defined
set of individuals using the <code>simplify_to =</code> argument.
Internally, simplification is implemented in a dedicated function
<code>ts_simplify()</code> which we can always call explicitly, like
this:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" tabindex="-1"></a>ts_small <span class="ot">&lt;-</span> <span class="fu">ts_simplify</span>(ts, <span class="at">simplify_to =</span> <span class="fu">c</span>(<span class="st">&quot;CH_1&quot;</span>, <span class="st">&quot;NEA_1&quot;</span>, <span class="st">&quot;NEA_2&quot;</span>, <span class="st">&quot;AFR_1&quot;</span>, <span class="st">&quot;AFR_2&quot;</span>, <span class="st">&quot;EUR_20&quot;</span>, <span class="st">&quot;EUR_50&quot;</span>))</span>
<span id="cb29-2"><a href="#cb29-2" tabindex="-1"></a>ts_small</span></code></pre></div>
<pre><code>#&gt; ╔═══════════════════════════╗
#&gt; ║TreeSequence               ║
#&gt; ╠═══════════════╤═══════════╣
#&gt; ║Trees          │     132496║
#&gt; ╟───────────────┼───────────╢
#&gt; ║Sequence Length│  100000000║
#&gt; ╟───────────────┼───────────╢
#&gt; ║Time Units     │generations║
#&gt; ╟───────────────┼───────────╢
#&gt; ║Sample Nodes   │         14║
#&gt; ╟───────────────┼───────────╢
#&gt; ║Total Size     │   19.0 MiB║
#&gt; ╚═══════════════╧═══════════╝
#&gt; ╔═══════════╤══════╤═════════╤════════════╗
#&gt; ║Table      │Rows  │Size     │Has Metadata║
#&gt; ╠═══════════╪══════╪═════════╪════════════╣
#&gt; ║Edges      │441206│ 13.5 MiB│          No║
#&gt; ╟───────────┼──────┼─────────┼────────────╢
#&gt; ║Individuals│     7│220 Bytes│          No║
#&gt; ╟───────────┼──────┼─────────┼────────────╢
#&gt; ║Migrations │     0│  8 Bytes│          No║
#&gt; ╟───────────┼──────┼─────────┼────────────╢
#&gt; ║Mutations  │     0│ 16 Bytes│          No║
#&gt; ╟───────────┼──────┼─────────┼────────────╢
#&gt; ║Nodes      │ 79249│  2.1 MiB│          No║
#&gt; ╟───────────┼──────┼─────────┼────────────╢
#&gt; ║Populations│     4│338 Bytes│         Yes║
#&gt; ╟───────────┼──────┼─────────┼────────────╢
#&gt; ║Provenances│     2│  7.7 KiB│          No║
#&gt; ╟───────────┼──────┼─────────┼────────────╢
#&gt; ║Sites      │     0│ 16 Bytes│          No║
#&gt; ╚═══════════╧══════╧═════════╧════════════╝</code></pre>
<p>Similarly, <em>slendr</em> provides a function
<code>ts_recapitate()</code> which performs [recapitation]<a href="https://tskit.dev/pyslim/docs/latest/tutorial.html#recapitation" class="uri">https://tskit.dev/pyslim/docs/latest/tutorial.html#recapitation</a>).
Again, this is not needed for an <em>msprime</em> tree sequence, which
is fully coalesced (and recapitated) by definition. If we do this on our
current tree sequence object, we simply get a warning informing us that
we’re attempting to do something that has no effect:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" tabindex="-1"></a>ts <span class="ot">&lt;-</span> <span class="fu">ts_recapitate</span>(ts, <span class="at">recombination_rate =</span> <span class="fl">1e-8</span>, <span class="at">Ne =</span> <span class="dv">10000</span>)</span></code></pre></div>
<p>We can make sure that our tree sequence is fully coalesced by calling
another <em>slendr</em> function <code>ts_coalesced()</code>. This is
useful when dealing with <code>slim()</code>-produced tree
sequences:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" tabindex="-1"></a><span class="fu">ts_coalesced</span>(ts)</span></code></pre></div>
<pre><code>#&gt; [1] TRUE</code></pre>
<p>You might have noticed that we did not simulate any mutations during
the SLiM run. This is for computational efficiency. Luckily, the
tree-sequence contains the complete history of a sample of individuals
which makes it very easy to sprinkle mutations on the genealogies after
this simulation is over. We can add mutations a given rate by
running:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" tabindex="-1"></a>ts <span class="ot">&lt;-</span> <span class="fu">ts_mutate</span>(ts, <span class="at">mutation_rate =</span> <span class="fl">1e-8</span>, <span class="at">random_seed =</span> <span class="dv">314159</span>)</span>
<span id="cb34-2"><a href="#cb34-2" tabindex="-1"></a>ts</span></code></pre></div>
<pre><code>#&gt; ╔═══════════════════════════╗
#&gt; ║TreeSequence               ║
#&gt; ╠═══════════════╤═══════════╣
#&gt; ║Trees          │     240041║
#&gt; ╟───────────────┼───────────╢
#&gt; ║Sequence Length│  100000000║
#&gt; ╟───────────────┼───────────╢
#&gt; ║Time Units     │generations║
#&gt; ╟───────────────┼───────────╢
#&gt; ║Sample Nodes   │        116║
#&gt; ╟───────────────┼───────────╢
#&gt; ║Total Size     │   76.8 MiB║
#&gt; ╚═══════════════╧═══════════╝
#&gt; ╔═══════════╤══════╤═════════╤════════════╗
#&gt; ║Table      │Rows  │Size     │Has Metadata║
#&gt; ╠═══════════╪══════╪═════════╪════════════╣
#&gt; ║Edges      │916588│ 28.0 MiB│          No║
#&gt; ╟───────────┼──────┼─────────┼────────────╢
#&gt; ║Individuals│    58│  1.6 KiB│          No║
#&gt; ╟───────────┼──────┼─────────┼────────────╢
#&gt; ║Migrations │     0│  8 Bytes│          No║
#&gt; ╟───────────┼──────┼─────────┼────────────╢
#&gt; ║Mutations  │623249│ 22.0 MiB│          No║
#&gt; ╟───────────┼──────┼─────────┼────────────╢
#&gt; ║Nodes      │189654│  5.1 MiB│          No║
#&gt; ╟───────────┼──────┼─────────┼────────────╢
#&gt; ║Populations│     4│338 Bytes│         Yes║
#&gt; ╟───────────┼──────┼─────────┼────────────╢
#&gt; ║Provenances│     2│  7.9 KiB│          No║
#&gt; ╟───────────┼──────┼─────────┼────────────╢
#&gt; ║Sites      │621331│ 14.8 MiB│          No║
#&gt; ╚═══════════╧══════╧═════════╧════════════╝</code></pre>
<p>Having processed the simulated tree sequence, we can calculate some
basic statistics on our simulated data.</p>
<p>However, before we do that, we would first like to note that
everything that we do in the rest of this vignette (i.e. whenever we
call a function with the prefix <code>ts_*()</code> in <em>slendr</em>),
we are interfacing with the <em>tskit</em> Python module under the hood.
Our goal is to capture most of the analyses one might want to perform on
tree-sequences in R and wrap them in a neat interface indistinguishable
from any other R function—this is, after all, the reason why
<em>reticulate</em> has been created in the first place (making various
Python data science modules appear as if they were regular R
packages).</p>
</div>
<div id="visualisation-of-trees-and-tree-sequences" class="section level2">
<h2>Visualisation of trees and tree-sequences</h2>
<p>Now we introduce a function <code>ts_phylo()</code> which can be used
to extract one tree from the tree-sequence (either an <em>i</em>-th tree
in the sequence, or a tree overlapping an <em>i</em>-th position of the
simulated genome, depending on the value of its <code>mode</code>
argument) and convert it to a <code>phylo</code> class, which is a
standard format for phylogenetic trees in the R world. For more on the
<code>phylo</code> format, see packages <a href="https://cran.r-project.org/package=ape">ape</a>, <a href="https://cran.r-project.org/package=phangorn">phangorn</a>, and <a href="https://cran.r-project.org/package=phytools">phytools</a>.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" tabindex="-1"></a><span class="co"># extract the 42nd tree in the tree sequence</span></span>
<span id="cb36-2"><a href="#cb36-2" tabindex="-1"></a>tree <span class="ot">&lt;-</span> <span class="fu">ts_phylo</span>(ts_small, <span class="dv">42</span> <span class="sc">-</span> <span class="dv">1</span>)</span></code></pre></div>
<pre><code>#&gt; Starting checking the validity of tree...
#&gt; Found number of tips: n = 14 
#&gt; Found number of nodes: m = 13 
#&gt; Done.</code></pre>
<p>When we type the tree object to an R console, we can verify that we
got an ordinary <code>phylo</code> object:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" tabindex="-1"></a>tree</span></code></pre></div>
<pre><code>#&gt; 
#&gt; Phylogenetic tree with 14 tips and 13 internal nodes.
#&gt; 
#&gt; Tip labels:
#&gt;   13 (EUR_50), 12 (EUR_50), 11 (CH_1), 10 (CH_1), 9 (AFR_2), 8 (AFR_2), ...
#&gt; Node labels:
#&gt;   77386, 70, 2699, 5175, 5199, 6642, ...
#&gt; 
#&gt; Rooted; includes branch lengths.</code></pre>
<p>This means that we have the whole R phylogenetic ecosystem at our
disposal to analyze such trees. For instance we can use the powerful
package <em>ggtree</em> to plot the tree we have just extracted:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" tabindex="-1"></a><span class="fu">library</span>(ggtree)</span>
<span id="cb40-2"><a href="#cb40-2" tabindex="-1"></a></span>
<span id="cb40-3"><a href="#cb40-3" tabindex="-1"></a><span class="fu">ggtree</span>(tree) <span class="sc">+</span></span>
<span id="cb40-4"><a href="#cb40-4" tabindex="-1"></a>  <span class="fu">geom_point2</span>(<span class="fu">aes</span>(<span class="at">subset =</span> <span class="sc">!</span>isTip)) <span class="sc">+</span> <span class="co"># points for internal nodes</span></span>
<span id="cb40-5"><a href="#cb40-5" tabindex="-1"></a>  <span class="fu">geom_tiplab</span>() <span class="sc">+</span> <span class="co"># sample labels for tips</span></span>
<span id="cb40-6"><a href="#cb40-6" tabindex="-1"></a>  <span class="fu">hexpand</span>(<span class="fl">0.1</span>)    <span class="co"># make more space for the tip labels</span></span></code></pre></div>
<div class="sourceCode" id="cb41"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1" tabindex="-1"></a><span class="fu">library</span>(ape)</span></code></pre></div>
<pre><code>#&gt; 
#&gt; Attaching package: &#39;ape&#39;</code></pre>
<pre><code>#&gt; The following object is masked from &#39;package:dplyr&#39;:
#&gt; 
#&gt;     where</code></pre>
<div class="sourceCode" id="cb44"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb44-1"><a href="#cb44-1" tabindex="-1"></a><span class="fu">plot</span>(tree)</span>
<span id="cb44-2"><a href="#cb44-2" tabindex="-1"></a><span class="fu">nodelabels</span>()</span></code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
</div>
<div id="accessing-tskit-functionality-directly" class="section level2">
<h2>Accessing <em>tskit</em> functionality directly</h2>
<p>As we mentioned in the previous section, the goal of this vignette is
to show how to use <em>slendr</em> to perform the main tree-sequence
operations using a convenient R interface to <em>tskit</em>. However,
you should always keep in mind that you are not restricted to a subset
of <em>tskit</em> functionality that <em>slendr</em> translated to R
(i.e. <a href="../reference/index.html">all functions</a> with the
prefix <code>ts_</code>). Thanks to the incredible R package <a href="https://rstudio.github.io/reticulate/index.html"><em>reticulate</em></a>,
you can access Python methods and object variables directly, using the
<code>$</code> operator.</p>
<p>As an example, instead of calling the function
<code>ts_coalesced()</code> on the tree-sequence as we did above, we
could check that all trees are coalesced by running the following
snippet instead (note that this is very inefficient and we’re only doing
the operation for the first one hundred trees):</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb45-1"><a href="#cb45-1" tabindex="-1"></a><span class="co"># iterate over all trees in the tree-sequence and check if each</span></span>
<span id="cb45-2"><a href="#cb45-2" tabindex="-1"></a><span class="co"># has only one root (i.e. is fully coalesced) - note that Python</span></span>
<span id="cb45-3"><a href="#cb45-3" tabindex="-1"></a><span class="co"># lists are 0-based, which is something we need to take care of</span></span>
<span id="cb45-4"><a href="#cb45-4" tabindex="-1"></a><span class="fu">all</span>(<span class="fu">sapply</span>(<span class="fu">seq_len</span>(ts<span class="sc">$</span>num_trees)[<span class="dv">1</span><span class="sc">:</span><span class="dv">100</span>],</span>
<span id="cb45-5"><a href="#cb45-5" tabindex="-1"></a>           <span class="cf">function</span>(i) ts<span class="sc">$</span><span class="fu">at_index</span>(i <span class="sc">-</span> <span class="dv">1</span>)<span class="sc">$</span>num_roots <span class="sc">==</span> <span class="dv">1</span>))</span></code></pre></div>
<p>We believe it makes sense to use the R interface whenever possible
(even if only because it makes many operations a little bit more
convenient). However, if there is some functionality in <em>slendr</em>
missing, you can always resort to accessing the Python objects directly
as we have just demonstrated. You can verify that all <a href="https://tskit.dev/tskit/docs/stable/python-api.html#tskit.TreeSequence">methods
and attributes</a> of a Python tree-sequence object is still accessible
in R:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1" tabindex="-1"></a><span class="fu">names</span>(ts)</span></code></pre></div>
<pre><code>#&gt;   [1] &quot;alignments&quot;                      &quot;allele_frequency_spectrum&quot;      
#&gt;   [3] &quot;as_fasta&quot;                        &quot;as_nexus&quot;                       
#&gt;   [5] &quot;as_vcf&quot;                          &quot;aslist&quot;                         
#&gt;   [7] &quot;at&quot;                              &quot;at_index&quot;                       
#&gt;   [9] &quot;breakpoints&quot;                     &quot;check_index&quot;                    
#&gt;  [11] &quot;coalescence_time_distribution&quot;   &quot;coiterate&quot;                      
#&gt;  [13] &quot;count_topologies&quot;                &quot;decapitate&quot;                     
#&gt;  [15] &quot;delete_intervals&quot;                &quot;delete_sites&quot;                   
#&gt;  [17] &quot;diffs&quot;                           &quot;discrete_genome&quot;                
#&gt;  [19] &quot;discrete_time&quot;                   &quot;divergence&quot;                     
#&gt;  [21] &quot;divergence_matrix&quot;               &quot;diversity&quot;                      
#&gt;  [23] &quot;draw_svg&quot;                        &quot;draw_text&quot;                      
#&gt;  [25] &quot;dump&quot;                            &quot;dump_tables&quot;                    
#&gt;  [27] &quot;dump_text&quot;                       &quot;edge&quot;                           
#&gt;  [29] &quot;edge_diffs&quot;                      &quot;edges&quot;                          
#&gt;  [31] &quot;edges_child&quot;                     &quot;edges_left&quot;                     
#&gt;  [33] &quot;edges_parent&quot;                    &quot;edges_right&quot;                    
#&gt;  [35] &quot;edgesets&quot;                        &quot;equals&quot;                         
#&gt;  [37] &quot;f2&quot;                              &quot;f3&quot;                             
#&gt;  [39] &quot;f4&quot;                              &quot;file_uuid&quot;                      
#&gt;  [41] &quot;first&quot;                           &quot;Fst&quot;                            
#&gt;  [43] &quot;genealogical_nearest_neighbours&quot; &quot;general_stat&quot;                   
#&gt;  [45] &quot;genetic_relatedness&quot;             &quot;genetic_relatedness_weighted&quot;   
#&gt;  [47] &quot;genotype_matrix&quot;                 &quot;get_ll_tree_sequence&quot;           
#&gt;  [49] &quot;get_num_mutations&quot;               &quot;get_num_nodes&quot;                  
#&gt;  [51] &quot;get_num_records&quot;                 &quot;get_num_sites&quot;                  
#&gt;  [53] &quot;get_num_trees&quot;                   &quot;get_pairwise_diversity&quot;         
#&gt;  [55] &quot;get_population&quot;                  &quot;get_sample_size&quot;                
#&gt;  [57] &quot;get_samples&quot;                     &quot;get_sequence_length&quot;            
#&gt;  [59] &quot;get_time&quot;                        &quot;haplotypes&quot;                     
#&gt;  [61] &quot;has_reference_sequence&quot;          &quot;ibd_segments&quot;                   
#&gt;  [63] &quot;impute_unknown_mutations_time&quot;   &quot;indexes_edge_insertion_order&quot;   
#&gt;  [65] &quot;indexes_edge_removal_order&quot;      &quot;individual&quot;                     
#&gt;  [67] &quot;individual_locations&quot;            &quot;individual_populations&quot;         
#&gt;  [69] &quot;individual_times&quot;                &quot;individuals&quot;                    
#&gt;  [71] &quot;individuals_flags&quot;               &quot;individuals_location&quot;           
#&gt;  [73] &quot;individuals_population&quot;          &quot;individuals_time&quot;               
#&gt;  [75] &quot;kc_distance&quot;                     &quot;keep_intervals&quot;                 
#&gt;  [77] &quot;last&quot;                            &quot;ll_tree_sequence&quot;               
#&gt;  [79] &quot;load&quot;                            &quot;load_tables&quot;                    
#&gt;  [81] &quot;ltrim&quot;                           &quot;max_root_time&quot;                  
#&gt;  [83] &quot;max_time&quot;                        &quot;mean_descendants&quot;               
#&gt;  [85] &quot;metadata&quot;                        &quot;metadata_schema&quot;                
#&gt;  [87] &quot;migration&quot;                       &quot;migrations&quot;                     
#&gt;  [89] &quot;migrations_dest&quot;                 &quot;migrations_left&quot;                
#&gt;  [91] &quot;migrations_node&quot;                 &quot;migrations_right&quot;               
#&gt;  [93] &quot;migrations_source&quot;               &quot;migrations_time&quot;                
#&gt;  [95] &quot;min_time&quot;                        &quot;mutation&quot;                       
#&gt;  [97] &quot;mutations&quot;                       &quot;mutations_node&quot;                 
#&gt;  [99] &quot;mutations_parent&quot;                &quot;mutations_site&quot;                 
#&gt; [101] &quot;mutations_time&quot;                  &quot;nbytes&quot;                         
#&gt; [103] &quot;newick_trees&quot;                    &quot;node&quot;                           
#&gt; [105] &quot;nodes&quot;                           &quot;nodes_flags&quot;                    
#&gt; [107] &quot;nodes_individual&quot;                &quot;nodes_population&quot;               
#&gt; [109] &quot;nodes_time&quot;                      &quot;num_edges&quot;                      
#&gt; [111] &quot;num_individuals&quot;                 &quot;num_migrations&quot;                 
#&gt; [113] &quot;num_mutations&quot;                   &quot;num_nodes&quot;                      
#&gt; [115] &quot;num_populations&quot;                 &quot;num_provenances&quot;                
#&gt; [117] &quot;num_samples&quot;                     &quot;num_sites&quot;                      
#&gt; [119] &quot;num_trees&quot;                       &quot;pairwise_diversity&quot;             
#&gt; [121] &quot;parse_windows&quot;                   &quot;population&quot;                     
#&gt; [123] &quot;populations&quot;                     &quot;provenance&quot;                     
#&gt; [125] &quot;provenances&quot;                     &quot;records&quot;                        
#&gt; [127] &quot;reference_sequence&quot;              &quot;rtrim&quot;                          
#&gt; [129] &quot;sample_count_stat&quot;               &quot;sample_size&quot;                    
#&gt; [131] &quot;samples&quot;                         &quot;segregating_sites&quot;              
#&gt; [133] &quot;sequence_length&quot;                 &quot;simplify&quot;                       
#&gt; [135] &quot;site&quot;                            &quot;sites&quot;                          
#&gt; [137] &quot;sites_position&quot;                  &quot;split_edges&quot;                    
#&gt; [139] &quot;subset&quot;                          &quot;table_metadata_schemas&quot;         
#&gt; [141] &quot;tables&quot;                          &quot;tables_dict&quot;                    
#&gt; [143] &quot;Tajimas_D&quot;                       &quot;time_units&quot;                     
#&gt; [145] &quot;to_macs&quot;                         &quot;to_nexus&quot;                       
#&gt; [147] &quot;trait_correlation&quot;               &quot;trait_covariance&quot;               
#&gt; [149] &quot;trait_linear_model&quot;              &quot;trait_regression&quot;               
#&gt; [151] &quot;trees&quot;                           &quot;trim&quot;                           
#&gt; [153] &quot;union&quot;                           &quot;variants&quot;                       
#&gt; [155] &quot;write_fasta&quot;                     &quot;write_nexus&quot;                    
#&gt; [157] &quot;write_vcf&quot;                       &quot;Y1&quot;                             
#&gt; [159] &quot;Y2&quot;                              &quot;Y3&quot;</code></pre>
<p>In fact, you will recognize some of the elements in the output above
from examples involving <code>ts_</code> functions in this vignette! In
short, there is no blackbox—<em>slendr</em> only provides a slightly
more convenient layer over <em>tskit</em> for R users.</p>
</div>
<div id="calculating-f-statistics" class="section level2">
<h2>Calculating <em>f</em>-statistics</h2>
<p>In addition to being a revolutionary breakthrough in terms of
computation efficiency, many statistics that we are often interested in
population genetics are a natural consequence of having a direct access
to tree sequence genealogies, simply because those genealogies capture
the true demographic history of a sample. Again, we can’t go into too
much detail here but we encourage you to take a look at a paper by <a href="https://doi.org/10.1534/genetics.120.303253">Ralph <em>et
al.</em></a> on the duality between statistics expressed in terms of
branch lengths and the traditional summaries based on samples of genetic
variation.</p>
<p>For instance, we have functions such as <code>ts_f2()</code>,
<code>ts_f3()</code>, <code>ts_f4()</code> and <code>ts_f4ratio()</code>
which calculate the well-known set of Patterson’s <span class="math inline">\(f\)</span>-statistics:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb48-1"><a href="#cb48-1" tabindex="-1"></a><span class="co"># f2 is a measure of the branch length connecting A and B</span></span>
<span id="cb48-2"><a href="#cb48-2" tabindex="-1"></a><span class="fu">ts_f2</span>(ts, <span class="at">A =</span> <span class="st">&quot;EUR_1&quot;</span>, <span class="at">B =</span> <span class="st">&quot;AFR_1&quot;</span>)</span></code></pre></div>
<pre><code>#&gt; # A tibble: 1 × 3
#&gt;   A     B            f2
#&gt;   &lt;chr&gt; &lt;chr&gt;     &lt;dbl&gt;
#&gt; 1 EUR_1 AFR_1 0.0000448</code></pre>
<div class="sourceCode" id="cb50"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb50-1"><a href="#cb50-1" tabindex="-1"></a><span class="co"># f4 is a measure of the drift shared between A and B after their split from C</span></span>
<span id="cb50-2"><a href="#cb50-2" tabindex="-1"></a><span class="fu">ts_f3</span>(ts, <span class="at">A =</span> <span class="st">&quot;EUR_1&quot;</span>, <span class="at">B =</span> <span class="st">&quot;AFR_1&quot;</span>, <span class="at">C =</span> <span class="st">&quot;CH_1&quot;</span>)</span></code></pre></div>
<pre><code>#&gt; # A tibble: 1 × 4
#&gt;   A     B     C            f3
#&gt;   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;     &lt;dbl&gt;
#&gt; 1 EUR_1 AFR_1 CH_1  0.0000130</code></pre>
<div class="sourceCode" id="cb52"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb52-1"><a href="#cb52-1" tabindex="-1"></a><span class="co"># this value should be very close to zero (no introgression in Africans)</span></span>
<span id="cb52-2"><a href="#cb52-2" tabindex="-1"></a><span class="fu">ts_f4</span>(ts, <span class="st">&quot;AFR_1&quot;</span>, <span class="st">&quot;AFR_2&quot;</span>, <span class="st">&quot;NEA_1&quot;</span>, <span class="st">&quot;CH_1&quot;</span>, <span class="at">mode =</span> <span class="st">&quot;branch&quot;</span>)</span></code></pre></div>
<pre><code>#&gt; # A tibble: 1 × 5
#&gt;   W     X     Y     Z        f4
#&gt;   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt;
#&gt; 1 AFR_1 AFR_2 NEA_1 CH_1  -118.</code></pre>
<div class="sourceCode" id="cb54"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb54-1"><a href="#cb54-1" tabindex="-1"></a><span class="co"># this value should be significantly negative (many more ABBA sites</span></span>
<span id="cb54-2"><a href="#cb54-2" tabindex="-1"></a><span class="co"># compared to BABA site due to the introgression into Europeans)</span></span>
<span id="cb54-3"><a href="#cb54-3" tabindex="-1"></a><span class="fu">ts_f4</span>(ts, <span class="st">&quot;AFR_1&quot;</span>, <span class="st">&quot;EUR_1&quot;</span>, <span class="st">&quot;NEA_1&quot;</span>, <span class="st">&quot;CH_1&quot;</span>, <span class="at">mode =</span> <span class="st">&quot;branch&quot;</span>)</span></code></pre></div>
<pre><code>#&gt; # A tibble: 1 × 5
#&gt;   W     X     Y     Z        f4
#&gt;   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt;
#&gt; 1 AFR_1 EUR_1 NEA_1 CH_1  -741.</code></pre>
<p>These functions accept a <code>mode =</code> argument, specifying
whether the statistics should be calculated using mutation site patterns
(<code>mode = &quot;site&quot;</code>, the default), branch lengths
(<code>mode = &quot;branch&quot;</code>), or for each node
(<code>mode = &quot;node&quot;</code>), as well as the <code>windows</code>
argument, similarly to other “multiway” statistics implemented by tskit.
See the <a href="https://tskit.dev/tskit/docs/stable/stats.html#sec-stats-mode">relevant</a>
<a href="https://tskit.dev/tskit/docs/stable/stats.html#sec-stats-sample-sets-multi-way">sections</a>
of the official <em>tskit</em> documentation for more on this topic.</p>
<p>Note that in the previous chunk we referred to individuals by their
names (not numeric IDs of nodes as you would do it with <em>tskit</em>
in Python). We allow this for readability and to make it easier to see
which individuals are which based on the specified sampling schedule
(the names are assigned to individuals based on the order of their
sampling). We can get an overview of the individuals scheduled for
sampling (i.e. permanently remembered) and their names with a helper
function <code>ts_samples()</code>:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb56-1"><a href="#cb56-1" tabindex="-1"></a><span class="fu">ts_samples</span>(ts)</span></code></pre></div>
<pre><code>#&gt; # A tibble: 58 × 3
#&gt;    name   time pop  
#&gt;    &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;
#&gt;  1 NEA_1 70000 NEA  
#&gt;  2 NEA_2 40000 NEA  
#&gt;  3 EUR_1 39171 EUR  
#&gt;  4 EUR_2 39134 EUR  
#&gt;  5 EUR_3 37739 EUR  
#&gt;  6 EUR_4 36531 EUR  
#&gt;  7 EUR_5 36362 EUR  
#&gt;  8 EUR_6 35945 EUR  
#&gt;  9 EUR_7 33900 EUR  
#&gt; 10 EUR_8 33854 EUR  
#&gt; # ℹ 48 more rows</code></pre>
<p>That said, if you would like to run some statistics on nodes rather
than on individuals, you can do it simply by using integer IDs instead
of character names in each function’s interface.</p>
</div>
<div id="estimating-neanderthal-ancestry-proportions" class="section level2">
<h2>Estimating Neanderthal ancestry proportions</h2>
<p>Let’s try to put these new tools to practice and estimate the
proportion of Neanderthal ancestry in Africans and Europeans in our
simulated data. We can do this using the Patterson’s <span class="math inline">\(f_4\)</span>-ratio statistic implemented in the
<code>ts_f4ratio()</code> function in <em>slendr</em> (you can find more
information about this particular version of the statistic in Petr
<em>et al.</em>, PNAS 2019):</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb58-1"><a href="#cb58-1" tabindex="-1"></a><span class="co"># first get a table of simulated African and European individuals in the tree-sequence</span></span>
<span id="cb58-2"><a href="#cb58-2" tabindex="-1"></a>inds <span class="ot">&lt;-</span> <span class="fu">ts_samples</span>(ts) <span class="sc">%&gt;%</span> dplyr<span class="sc">::</span><span class="fu">filter</span>(pop <span class="sc">%in%</span> <span class="fu">c</span>(<span class="st">&quot;AFR&quot;</span>, <span class="st">&quot;EUR&quot;</span>))</span>
<span id="cb58-3"><a href="#cb58-3" tabindex="-1"></a></span>
<span id="cb58-4"><a href="#cb58-4" tabindex="-1"></a><span class="co"># estimate the amounts of Neanderthal ancestry in these individuals and add</span></span>
<span id="cb58-5"><a href="#cb58-5" tabindex="-1"></a><span class="co"># these values to the table</span></span>
<span id="cb58-6"><a href="#cb58-6" tabindex="-1"></a>inds<span class="sc">$</span>ancestry <span class="ot">&lt;-</span> <span class="fu">ts_f4ratio</span>(ts, <span class="at">X =</span> inds<span class="sc">$</span>name, <span class="st">&quot;NEA_1&quot;</span>, <span class="st">&quot;NEA_2&quot;</span>, <span class="st">&quot;AFR_1&quot;</span>, <span class="st">&quot;CH_1&quot;</span>)<span class="sc">$</span>alpha</span></code></pre></div>
<p>If we now summarise the inferred Neanderthal distribution in both
populations, we see that there is no Neanderthal ancestry in Africans
(as expected by our model–Africans did not receive a Neanderthal
introgression pulse) but there is a small proportion of Neanderthal
ancestry in Europeans (consistent with the 3% introgression pulse we
simulated between):</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb59-1"><a href="#cb59-1" tabindex="-1"></a><span class="fu">ggplot</span>(inds, <span class="fu">aes</span>(pop, ancestry, <span class="at">fill =</span> pop)) <span class="sc">+</span></span>
<span id="cb59-2"><a href="#cb59-2" tabindex="-1"></a>  <span class="fu">geom_boxplot</span>() <span class="sc">+</span></span>
<span id="cb59-3"><a href="#cb59-3" tabindex="-1"></a>  <span class="fu">geom_jitter</span>() <span class="sc">+</span></span>
<span id="cb59-4"><a href="#cb59-4" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">y =</span> <span class="st">&quot;Neanderthal ancestry proportion&quot;</span>, <span class="at">x =</span> <span class="st">&quot;&quot;</span>) <span class="sc">+</span></span>
<span id="cb59-5"><a href="#cb59-5" tabindex="-1"></a>  <span class="fu">theme</span>(<span class="at">legend.position =</span> <span class="st">&quot;none&quot;</span>) <span class="sc">+</span></span>
<span id="cb59-6"><a href="#cb59-6" tabindex="-1"></a>  <span class="fu">coord_cartesian</span>(<span class="at">ylim =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="fl">0.1</span>))</span></code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<p>This is exactly as we specified in the model configuration above,
suggesting that our simulations work as they should. You can see that
there is quite a bit of noise but that’s because we simulated only a
small amount of sequence.</p>
<p>We can also plot the trajectory of Neanderthal ancestry in Europe
during the time-window for which we have simulated ancient and
present-day DNA samples:</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb60-1"><a href="#cb60-1" tabindex="-1"></a>dplyr<span class="sc">::</span><span class="fu">filter</span>(inds, pop <span class="sc">==</span> <span class="st">&quot;EUR&quot;</span>) <span class="sc">%&gt;%</span></span>
<span id="cb60-2"><a href="#cb60-2" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(time, ancestry)) <span class="sc">+</span></span>
<span id="cb60-3"><a href="#cb60-3" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb60-4"><a href="#cb60-4" tabindex="-1"></a>  <span class="fu">geom_smooth</span>(<span class="at">method =</span> <span class="st">&quot;lm&quot;</span>, <span class="at">linetype =</span> <span class="dv">2</span>, <span class="at">color =</span> <span class="st">&quot;red&quot;</span>, <span class="at">linewidth =</span> <span class="fl">0.5</span>) <span class="sc">+</span></span>
<span id="cb60-5"><a href="#cb60-5" tabindex="-1"></a>  <span class="fu">xlim</span>(<span class="dv">40000</span>, <span class="dv">0</span>) <span class="sc">+</span> <span class="fu">coord_cartesian</span>(<span class="at">ylim =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="fl">0.1</span>)) <span class="sc">+</span></span>
<span id="cb60-6"><a href="#cb60-6" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">x =</span> <span class="st">&quot;time [years ago]&quot;</span>, <span class="at">y =</span> <span class="st">&quot;Neanderthal ancestry proportion&quot;</span>)</span></code></pre></div>
<pre><code>#&gt; `geom_smooth()` using formula = &#39;y ~ x&#39;</code></pre>
<p><img src="data:image/png;base64,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exswYMAvLnUkAiIgAiJQVAKRozj69OnjzBsvvPCCTZo0yQ477LCiJkyRiYAIiEB1JxCpoEeOHGkLFy60YcOG2QEHHGAnnnhidWel/IuACIhAUQlEmjjef/99e+KJJ1xitttuO3v88cdt1apVsVoJraikFJkIiIAIFJlApILu0aOHXXnllXbUUUc5E0fclqksMidFJwIiIAJFJxBp4rjqqqucaeOuu+6y9evX2+jRo4ueOEUoAiIgAtWZQIqCfvfdd2369On27LPP2pdffmkMt9uwYYObVVidQSnvIiACIlBsAikmDr8rCYvf16lTp9jpUXwiIAIiIAI/E0hR0Hvvvbe7NW/ePDviiCMSoJ577jm3a4HfMSBxQwciIAIiIAIFIZCioGfMmGG33XabjR8/3vr27esiZTuZ559/3p1LQRfkOShQERABEUghkKKgWRyJGYTUoJnqjaCUL774YsPsIREBERABESgOgRSNy3C6/fff36644grbfffdjU1Gy5L77rvPfvjhBxs0aFCple9eeuklNzyvd+/e1qZNG3vwwQddMIylvvDCC23ChAn20UcfuWus8bHllluWFY3uiYAIiEC1I5AyisMT2GeffdziSJg77rjjDvfn7/lfJrO0aNHCzj//fBs7dqy/bD/++KNNnTrV1bqZKt6uXTun8E877TSrX7++U8YTJ0501ygIpJwT6HQgAiIgAgkCKTVof4da9Ny5c91p1I652KuZ0FK3bt1S257Pnj3b1aYxjTRv3tyWLFnilPCdd95p5557rgvz66+/tttvv91WrFhhF110kTF65JFHHrH777/funTpYjfeeKNPSsa/1P6Jk0IjLkJ66tWrF5fkOM7iE/04MOPxzsZF4vj+MLorSicUmxt88rmLdq7pJz0IFdF8SKSCPvjgg+2hhx4yRm+0bdvWrQ2dHCGJoQMRCdunUZT+Or8lJSVuXY/atWsnasujRo1yip3p5NSm99xzTzdrkY5JlDXrgGQrpAGTzOLFi7P1WjD3PKiVK1cWLPxsA0Y5V4RttvFk6j5ufFDOtADjooDixqdJkyZuyYe1a9dm+ogL6o7K4bp169xcjYJGlGHgXjFX5JvfaqutUmKJVNAsloSiZLGkTz75xC2W9Pbbb5cKYMcdd7R33nnHGjdunKglzpw509Wen3rqKcP+TO2ZROMOswmC0r755pvtggsusC+++CJxnZLZj71eunRpqbiyOYnLx+XTrPR4Eul/48gnTmmKW1pIT1zS5NMSl/Twhvs0pX/bs7saqaAzWSype/furjR9/fXX7fTTT3cxT5s2zSnok046ydW+sTsjrVu3drZojql5//a3v7VHH33UdS7SiSgRAREQAREoTSBSQWe6WNIee+xh/HnxY6c7depk/HlhynhYku+H7+lYBERABEQgqMxGQdBiSVFkdF0EREAEikMgUkHTCcBY5fnz57tFk1gwSSICIiACIlA8ApEKevDgwUaP7ZAhQ5wJg4koEhEQAREQgeIRiLRBU3M+77zzXIdet27d3Bhlxiw3aNCgeKlTTCIgAiJQjQlEKmi2uWI3lcMPP9zNCmSN6H/961/WrFkzO+6446oxMmVdBERABIpDIFJBs1Hs9ttv71Kx0047GX8IY6MlIiACIiAChScQqaD79OmTMpOwffv2hU+RYhABERABEXAEIjsJmUnIlGBmElKbPvHEE4VMBERABESgiAQia9CZzCQsYjoVlQiIgAhUOwKRCjrTmYTVjpgyLAIiIAJFIhBp4mAhI0wbd911l61fv95Gjx5dpCQpGhEQAREQAQhE1qAZXseuKIceeqhIiYAIiIAIVAKBSAXtd1Thl3WckTPPPLMSkqgoRUAERKB6EohU0JnsqFI9kSnXIiACIlAcApE2aEwb7OyNmePLL7+0gQMHFidFikUEREAERMARiFTQWixJb4gIiIAIVC6BSBOHFkuq3Aej2EVABEQgUkFrsSS9HCIgAiJQuQQiFbQWS6rcB6PYRUAERKBGsAPtT3HEUJFdvdmMtqSkxG1kG5c8sUt5XLaoh0nDhg1t+fLlccHjdnGPEx/WO2fd87hI3N6funXr2rp16ywuOyxtscUWLi1xUWM8L6Qi73Tjxo1TXrvIGnSKyyJfqMhHwnhtHlhF/BYye3FKT/369cWnjIddr149W7lypcXlgyepcXp/+L5Wr15dIQVUBvYK34pbgUFGeHd4h7KVdAo6chRHtoHLvQiIgAiIQH4JRCroV155xRYvXpzf2BSaCIiACIhAxgQiFfSSJUvc1lYnnHCCvfjii7GxOWWcMzkUAREQgSpOIFJBH3vssfbyyy+7Xb3HjRtn7KZy1VVX2YIFC6p4lpV8ERABEagaBCI7CWfPnm0PPvigPf3007bDDjvYww8/7GrRgwYNsjfeeKNq5E6pFAEREIEqTCBSQY8YMcJ22WUXwxbN0CMvc+bM8Yf6FQEREAERKCCBSBPHhAkTDDNHWDmTDu1NWMCnoaBFQAREIEQgsgat9aBDlHQoAiIgApVAIFJBt2zZ0liPA2Hg9aRJk2zjxo3GbD2JCIiACIhA4QmkKOgZM2bYbbfdZuPHj7e+ffu6FKCYsUVLQRf+gSgGERABEfAEUhR0x44dbcCAAbZo0SLr37+/c0et+eKLL3bTqL1H/YqACIiACBSWQIqCrlGjhrHdFX8I5o3p06fbVlttVdiUKHQREAEREIFSBFIUtL+LmYMFP6g9P/HEE4ZN+qmnnvK39SsCIiACIlBgApE9fswivPTSS+2hhx6y559/3po0aRKrZSoLzEXBi4AIiEClE4hU0NScx44d62rOrM08d+5ct5ZwpadYCRABERCBakIgUkHfeOONNnXqVDei49NPP7Xrr7++miBRNkVABEQgHgQiFXTbtm2te/fudscdd7hdSlq0aBGPFCsVIiACIlBNCEQq6JEjR9rChQtdLbpNmzZ21llnVRMkyqYIiIAIxINApIKeOHGinXfeea72TE2aYXZsdSMRAREQAREoDoFIBd27d2/705/+5GrRt99+uxsPzf5fycIGpIyTThY2TcSGzQaTyPfff29fffWVzZw5050zKxF/cdpvzSVM/0RABEQgJgQiFTQmjW233dZ23HFHY4nRm266KSXJLN4/bNgwo7bNiA8v69evdwv9T5s2zVi2FBk1apR9+OGH9vHHH7vz0aNH25QpU1znI+4lIiACIiACpQlETlS5+uqrDdszivXRRx+1c8891/2GvbMk6cCBA61nz5523XXXJW5988031q1bNzdlfOjQoa6WzDbt7Ci91157udo4NWemlHN98uTJbu1pNgmght2oUSNXOCQCzPCgVq1abmJNSUlJhj4K74w0xSk9zBSNU3riyicuu3rHjQ/pqV27tvEexUHYZZy00CKPg5Ae3p18fWORCvrzzz+3G264weWZXVSeeeYZW7NmTamI2VS2a9euKVxYxwMlizRs2NDmz59vu+22m9uZhRr3lVdead5cgrtly5Y5tyzUxKJMW2+9ddpwnaMy/jF2mz8fdhlOi3bLv0BFi7CciHiZxScaEu9Pvj6u6FgyvxO39wcFXadOndisy0N6UM5xKVB5Xki+CrBIBU0N+JJLLrF+/fo5U0S6UqF58+bORt2lSxcDlBeuUytGmOTSuHFj69Gjh+GudevWDii2a4SRIizQhBxwwAHuj2MmxmQrlOwUCGx4Gxdhw4M42dn5uMQn+u3gHeKdjcsHH7f3hxnFq1atMvqY4iBUNujnoiUeB+F58e6wTEa2goUhWSJt0NSeqR0//vjjTsGyNkey0JH45ptv2vDhw61Xr17u9pgxY5zC5SXHPNKuXTs3TZxw7rrrLmc2adasmTOB3HrrrTZr1izr3LlzctA6FwEREIFqT6BGoO1/ypUCnXy+ah8OK/l6eedhv7nUoDGxxEXiVgNi0StMTnGRuPFhQhatujx8FnlBHDc+qkGX/VhzqUHT55cskSYORmiMGzeu1AJJl112WbJ/d55OOXMj+Xp552kD10UREAERqKYEIhX0mWee6UZcePtwNeWjbIuACIhApRGIVNA0hVlulF5tiQiIgAiIQPEJRCroXXfd1W15dcghhySGHWk9juI/IMUoAiJQfQlEKuj27du7iSTVF41yLgIiIAKVSyDSfrHHHnu4iSmMmWVCCtOyJSIgAiIgAsUjEKmgMWcwweLJJ590q9h9++23xUuVYhIBERABEbBIBc04UIbVMTbvz3/+szE7kKneEhEQAREQgeIQiFTQrP/Mbt6tWrVyG8eyVKhGdBTnoSgWERABEYBApIJmT8KmTZvaNddcY++++64NHjzYrWIlbCIgAiIgAsUhEDmKgwWO+vTp41LBmhkSERABERCB4hKIrEEXNxmKTQREQAREIJlASg36vffes88++yzZnTs/44wz0l7XRREQAREQgfwTSFHQrKvq9xHMf3QKUQREQAREIFMCKQqadZ35Y5PXxx57zI2BZshdRZb/zDQRcicCIiACIpBKINIGrYkqqbB0RQREQASKSSBSQWuiSjEfg+ISAREQgVQCkQpaE1VSYemKCIiACBSTQKSC1kSVYj4GxSUCIiACqQRSOgm9E/YP/PLLL23ChAm2zTbbuKF3v/nNb/ztgv+WlJRkHQc7izMdvSJ+s44sQw9s8xWn9LAdfJzSE1c+cdmTMG58+MbY+Zz3KA4CH9KycePGOCTHbfPHu5OvbyxSQTPmuWfPnm737crIOQVERQQ4FfVbkfjK88OwxTilh/TGKT1x5RMXBR03PnCJU5ooMHif46KgYZPPbyxSQTdr1sytYudiq4R/PqPZRE3t2b9A2fgrpFulp2y6ceVDuuIgceODIuSvIt9nIXjGLT08r3w+sxQF/Z///McmTZrkWJ544om2zz77JHbn1pZXhXjFFKYIiIAIpCeQoqCphdJs2GuvvdL70FUREAEREIGiEEhR0HvvvbfxR0163333TSTiueeec00brQmdQKIDERABESgogRQFPWPGDLvtttts/Pjx1rdvXxc5dp7nn3/enUtBF/R5VKnAp0+fbosWLbI999wzcjMHNnqoX7++25mnSmVOiRWBGBBIUdAdO3Z0u3nPmzfP+vfv75KIUr744osTtugYpDurJJAXCp4dd9zRWOe6OsgPP/xgs2bNcnlu0KBB3rP88ssv25/+9Ce3DVq3bt3sgQceSNnQYciQIfbiiy/aggUL7P7777df/epXeU+HAhSBzZlAioJmTOH+++9vV1xxhe2+++7WsGHDKp3/+fPnG+O3V61a5Uw0r7zyymZfm2Nhq4EDB7o88zzJc8uWLfP6HG+++Wb77rvvXJgzZ850u77vsssuiTi++OILt9gWBQVy00032bhx4xL3i3VAOu6++243LpW9NRk3K/mFwMqVK+3999937wcVGEm8CES+rYzeYNQGvwxMR84888x4pT6D1IwdO9Zmz56dcPnCCy/Y6aefnjiv7IMrr7zSbSlGQfLSSy9Z27Ztc07SXXfd5WrPBISCfvXVV+2EE05IG+7ChQuNvy5dukSaKdJ5pDb86aefuiFFS5YscZsKh91h1gjX3L0yD7sp9DE19yOOOMKWL1/u3mEqG5deemmho60y4TN++KijjnLfB8ejRo2yww8/vMqkvzokNHKqN7Xo3r17J2bGxGVcaLYPhVqBbwWgNPJdk8w2PWH3EydOtKeeesq8LZfp9fmQnXbaydl9CatevXqReabmywfKcMpBgwZltWs7LayDDjrIKUBqxsw2DQvn1113nWEy69evnz355JPh20U5plBo1KiRi4s1zt95552ixFtVImFjDsx/FLArVqwwKjOSeBGIrEEfeuih7qP65JNP7OCDD7ZOnTrFK+UZpoZ8nHfeefa///3PKQpvV8/Qe0GdUbOlduclX7VMlO7UqVPd9Hzyy/NLJ1dffbXRiYfwgTKtn4I5E0HxY1cuS1Dg/FWW0CrYfvvtbenSpa6gimpFZJI+5gbQytlv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MZmk4+abb3b2L2o62Jvffvtt22mnnVyt8L777rOXX37Ztt56a9tyyy2tvPNM4qsqblgs5t5777W33nrL5Z8pueXl/6WXXrInn3zSdYixgFXyeVXJe6bpZKXE1157zS1exQJeyflNPv/444/tgQcesO+//96tHZN8nmm8Vckdi5qxzjsL9yTnN/mcDsO7777buWPJYTiFz6tbLTuZRz7yX6Vs0M8//7x99NFHrsf2scces759+7oOi4cfftjef/99Yx2F888/320eUN55VfpoMkkra3Dvuuuu9rvf/c4efPDBcnnQ28yONxdffLG98MIL7qMMn8dlOclM8p6JmyVLlhijfM455xz797//bT/88EO5+X/66aftoosuMj481oZJPs8k3qrk5sUXXzS+K1ghyflNPr///vvtD3/4g1sMDcWefF6V8p6PtBYi/1VGQX/77bduCJ1ff/rrr792LwZDovh4GB7FsqcsP4hyKe88Hw8kTmGwYiAs/vKXvxirDJaX/9mzZ7tVBynlGd6DcmbZV3/uP9I45TGXtNCiOO6441xBxFKQ1PbC+U3OPwqcoWSsn817xaYT4XMKxM1NDjroIDvmmGNctlhSNJzfdPnHHl2vXj3bbrvtjO8x+Xxz41NefgqR/yqjoNkii5XYUMY0tRA/9tF3WvhaXybn5cGuivdpQWCxoqaDoi2LB4rH3+eXjtXw+ebYkYjSxUTGULHy8u8Let4DuMBjc+cT7lwPvz/l5d/f999M8rm/Xl1+85n/KqOgabpjF+PDoTa044472rvvvmvvvfeebb/99u6cZtacOXNcqc79ss43t5flww8/tKeeesqNYmG7sPLyT+1x0qRJrlVCbZn1ucPncZmIkK/nxAYRf/vb3+y0005z26zR2gjnNzn/9GFQ08Ye+8knn7idg8LnfpOJfKUvbuFQIIXzS8s1fE7+2RyD9dz5znjfks/jlqdCp6cQ+a9yozjoBKMJTynFhAuUy1FHHeWG/rBlFhvR9u/f3ynx8s4L/cCKHf4rr7ziFC6TUZjJVF7+MYPQyXrggQe6bcaSz4ud/kLGN3PmTHvjjTcSUZxwwgmuNVZW/lHO48ePd/tlsmdm8nkisM3oAIVLhzMKODm/yecobPoveNf69OnjFHj4fDPCklFWknlk5KkcR1VOQZeTH90WAREQgc2GQJUxcWw2xJURERABEciQgBR0hqDkTAREQASKTUAKutjEFV+ZBBiZw4p7yE033VSm20xuMib8wgsvjNU+jOnSTYcl6WQTZokIeAJS0J6EfmNBgE6722+/3aVlhx12yDlNzCxlhTpGZcRZGInE7vaMxpGIgCcgBe1J6DcWBJiuzsiJ//znP27YIIlidih/TKRgpttJJ53kZpAy2YbFaW699VY7/vjj7e9//7ubLZickVatWjl/zz77rLv15Zdf2o033pjW79KlS93suAEDBrjRQUxoYYr4JZdcYr169XI1cYbqDRw40M4991wXRji+IUOG2NFHH+3SyjBQhDH8hEc6mbmJ/O9//3OzPlmWkrwyfLQiawi7wPRvsyUgBb3ZPtqqmbFTTjnFTeHfd999E7XJJ554wiloJpmcccYZNmbMmMQUf9bWYCr2uHHjjC3vWVsknbB+Mf4Q1ijZeeed3bocyX4ZmnjYYYe5yT777LOPU+xMjkJRs1YHY6JZJJ54SCOTX7zgBhMN6b3hhhtsxIgRbqgjBc7jjz/uZubhH7nmmmucCQc3KG0/6cqHpV8RgIAUtN6D2BOgZsl063bt2tluu+3mFtNv3bq1zZs3z1ifhdooNehXX33VKdB0GWJc77p165yiZfz8IYccktZv9+7dXTgsSk/NmfU7EJQ1ExGoRSMs0MUkKa55YaYr4/OpQQ8dOtT5ZdbrwQcf7MbpH3HEEc4pCp+ZerjH9MI0fWzQEhFIJiAFnUxE55VKIDzF2CckvLYutdewsIoaCpEaNOYFlGGUnHzyyXb55Zfbfvvt52rB6fz+9a9/dROh/GJcvmZbu3ZtFywTXgiHRbtICwt1eaFWjfKltswiS/hFsXu78sSJE53Trbbayk0o8v5QznHaps2nS7+VTyA/q0pXfj6Ugs2EADVdasXYmzMRlPPgwYNdbRYTA0vQRgkLAXm3uEnnF/MGNmNWvGPFP5ZhZeq8F2rxKF+WHWCBIGzjXvbee2+75ZZbnG2amjT+qZEzDZoaOS0BbM2sA3L22We7+JctW2bMamQdFYkIJBPQTMJkIjqvdAJ0/FGT5i9TwRSB8ksWOuGw8WJzZlkAlCHTkcOS7BdTSHkL3rC2R9i8EQ4vfA8bNZ2AdCoyhI5a9siRI51z4gjvAMSQQGrgviMxHKaOqyeBzL+A6slHua4EAn41wmyiTqec8U8N+KqrrnLKkTVKOE6WZL+YM8pbzS9KORN2+B62cmrjgwYNcsMHMbF4oQDyK8hNmDDBraeMXVoiAp6AatCehH5FQAREIGYEVIOO2QNRckRABETAE5CC9iT0KwIiIAIxIyAFHbMHouSIgAiIgCfw/wHWwB7M/szq2wAAAABJRU5ErkJggg==" /><!-- --></p>
<p>Again, this is a result consistent with empirical estimates of
Neanderthal ancestry using ancient DNA data (see Petr <em>et al.</em>,
PNAS 2019).</p>
</div>
<div id="admixtools-analyses" class="section level2">
<h2>ADMIXTOOLS analyses</h2>
<p>In case you would like to verify some <em>f</em>-statistics results
using the venerable <a href="https://doi.org/10.1534/genetics.112.145037">ADMIXTOOLS</a>
software (see the linked paper which formally introduced these
statistics in the first place), you can convert the tree-sequence data
to a file format called EIGENSTRAT using the
<code>ts_eigenstrat()</code> function. The file conversion is internally
handled by the R package <a href="https://bodkan.net/admixr/"><em>admixr</em></a> and returns an
<code>EIGENSTRAT</code> object which ties all individual
<code>EIGENSTRAT</code> file components together (see the <a href="https://bodkan.net/admixr/articles/01-tutorial.html">tutorial</a>
to <em>admixr</em> for an extensive overview). <em>admixr</em> is an R
package for running automated ADMIXTOOLS analyses entirely from R and
makes these types of analyses very convenient.</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb62-1"><a href="#cb62-1" tabindex="-1"></a>snps <span class="ot">&lt;-</span> <span class="fu">ts_eigenstrat</span>(ts, <span class="at">prefix =</span> <span class="fu">file.path</span>(<span class="fu">tempdir</span>(), <span class="st">&quot;eigenstrat&quot;</span>, <span class="st">&quot;data&quot;</span>))</span></code></pre></div>
<pre><code>#&gt; 1282 multiallelic sites (0.206% out of 621331 total) detected and removed</code></pre>
<p>Running an <em>admixr</em> analysis is then as easy as plugging the
object into an <em>admixr</em> function. For instance, we can estimate
the proportion of Neanderthal ancestry in a couple of individuals <span class="math inline">\(X\)</span> like this (<em>admixr</em> calls this
proportion <code>alpha</code>):</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb64-1"><a href="#cb64-1" tabindex="-1"></a><span class="fu">library</span>(admixr)</span>
<span id="cb64-2"><a href="#cb64-2" tabindex="-1"></a></span>
<span id="cb64-3"><a href="#cb64-3" tabindex="-1"></a><span class="fu">f4ratio</span>(<span class="at">data =</span> snps, <span class="at">X =</span> <span class="fu">c</span>(<span class="st">&quot;EUR_1&quot;</span>, <span class="st">&quot;EUR_2&quot;</span>, <span class="st">&quot;AFR_2&quot;</span>),</span>
<span id="cb64-4"><a href="#cb64-4" tabindex="-1"></a>        <span class="at">A =</span> <span class="st">&quot;NEA_1&quot;</span>, <span class="at">B =</span> <span class="st">&quot;NEA_2&quot;</span>, <span class="at">C =</span> <span class="st">&quot;AFR_1&quot;</span>, <span class="at">O =</span> <span class="st">&quot;CH_1&quot;</span>)</span></code></pre></div>
<p>In fact, lets compare the values obtained by both <em>tskit</em> and
<em>admixr</em>/ADMIXTOOLS for all individuals:</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb65-1"><a href="#cb65-1" tabindex="-1"></a>europeans <span class="ot">&lt;-</span> inds[inds<span class="sc">$</span>pop <span class="sc">==</span> <span class="st">&quot;EUR&quot;</span>, ]<span class="sc">$</span>name</span>
<span id="cb65-2"><a href="#cb65-2" tabindex="-1"></a></span>
<span id="cb65-3"><a href="#cb65-3" tabindex="-1"></a><span class="co"># tskit result</span></span>
<span id="cb65-4"><a href="#cb65-4" tabindex="-1"></a>result_ts <span class="ot">&lt;-</span> <span class="fu">ts_f4ratio</span>(ts, <span class="at">X =</span> europeans, <span class="at">A =</span> <span class="st">&quot;NEA_1&quot;</span>, <span class="at">B =</span> <span class="st">&quot;NEA_2&quot;</span>, <span class="at">C =</span> <span class="st">&quot;AFR_1&quot;</span>, <span class="at">O =</span> <span class="st">&quot;CH_1&quot;</span>) <span class="sc">%&gt;%</span> <span class="fu">select</span>(<span class="at">alpha_ts =</span> alpha)</span>
<span id="cb65-5"><a href="#cb65-5" tabindex="-1"></a></span>
<span id="cb65-6"><a href="#cb65-6" tabindex="-1"></a><span class="co"># result obtained by admixr/ADMIXTOOLS</span></span>
<span id="cb65-7"><a href="#cb65-7" tabindex="-1"></a>result_admixr <span class="ot">&lt;-</span> <span class="fu">f4ratio</span>(snps, <span class="at">X =</span> europeans, <span class="at">A =</span> <span class="st">&quot;NEA_1&quot;</span>, <span class="at">B =</span> <span class="st">&quot;NEA_2&quot;</span>, <span class="at">C =</span> <span class="st">&quot;AFR_1&quot;</span>, <span class="at">O =</span> <span class="st">&quot;CH_1&quot;</span>) <span class="sc">%&gt;%</span> <span class="fu">select</span>(<span class="at">alpha_admixr =</span> alpha)</span>
<span id="cb65-8"><a href="#cb65-8" tabindex="-1"></a></span>
<span id="cb65-9"><a href="#cb65-9" tabindex="-1"></a><span class="fu">bind_cols</span>(result_admixr, result_ts) <span class="sc">%&gt;%</span></span>
<span id="cb65-10"><a href="#cb65-10" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(alpha_ts, alpha_admixr)) <span class="sc">+</span></span>
<span id="cb65-11"><a href="#cb65-11" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb65-12"><a href="#cb65-12" tabindex="-1"></a>  <span class="fu">geom_abline</span>(<span class="at">slope =</span> <span class="dv">1</span>, <span class="at">linetype =</span> <span class="dv">2</span>, <span class="at">color =</span> <span class="st">&quot;red&quot;</span>, <span class="at">linewidth =</span> <span class="fl">0.5</span>) <span class="sc">+</span></span>
<span id="cb65-13"><a href="#cb65-13" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">x =</span> <span class="st">&quot;f4-ratio statistic calculated with admixr/ADMIXTOOLS&quot;</span>,</span>
<span id="cb65-14"><a href="#cb65-14" tabindex="-1"></a>       <span class="at">y =</span> <span class="st">&quot;f4-ratio statistic calculated with tskit&quot;</span>)</span></code></pre></div>
<p>The correspondence between the two looks good! 🎉 Again, note that
the large amount of variance around the expected value of 3% ancestry is
due to an extremely small amount of sequence data simulated here.</p>
</div>
<div id="vcf-output" class="section level2">
<h2>VCF output</h2>
<p>In case you need to process simulated data in some other software,
you can use the function <code>ts_vcf()</code> to save the simulated
genotypes in a VCF format:</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb66-1"><a href="#cb66-1" tabindex="-1"></a><span class="fu">ts_vcf</span>(ts, <span class="at">path =</span> <span class="fu">file.path</span>(<span class="fu">tempdir</span>(), <span class="st">&quot;output.vcf.gz&quot;</span>))</span></code></pre></div>
<p>You can also specify only a subset of individuals to be saved in the
VCF:</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb67-1"><a href="#cb67-1" tabindex="-1"></a><span class="fu">ts_vcf</span>(ts, <span class="at">path =</span> <span class="fu">file.path</span>(<span class="fu">tempdir</span>(), <span class="st">&quot;output_subset.vcf.gz&quot;</span>),</span>
<span id="cb67-2"><a href="#cb67-2" tabindex="-1"></a>       <span class="at">individuals =</span> <span class="fu">c</span>(<span class="st">&quot;CH_1&quot;</span>, <span class="st">&quot;NEA_1&quot;</span>, <span class="st">&quot;EUR_1&quot;</span>, <span class="st">&quot;AFR_1&quot;</span>))</span></code></pre></div>
</div>
<div id="other-statistics" class="section level2">
<h2>Other statistics</h2>
<p>What follows is a very brief overview of other statistics which are
implemented in <em>tskit</em> and for which <em>slendr</em> provides an
easy-to-use R interface. As you will see, the goal of these functions is
to get you to a result using a single function call, making them very
convenient for quick interactive exploratory analyses on the simulated
data right in the R console.</p>
<p>We will continue to use our simulated Neanderthal introgression
tree-sequence data for these examples.</p>
<div id="f_st" class="section level3">
<h3><span class="math inline">\(F_{st}\)</span></h3>
<p>The <span class="math inline">\(F_{st}\)</span> statistic is
implemented by the function <code>ts_fst()</code>.</p>
<p>If a single genome-wide <span class="math inline">\(F_{st}\)</span>
is to be calculated (i.e. not a window-based calculation), the
<code>ts_fst()</code> returns a simple three-column data frame</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb68-1"><a href="#cb68-1" tabindex="-1"></a><span class="fu">ts_fst</span>(ts, <span class="at">sample_sets =</span> <span class="fu">list</span>(<span class="at">afr =</span> <span class="fu">c</span>(<span class="st">&quot;AFR_1&quot;</span>, <span class="st">&quot;AFR_2&quot;</span>, <span class="st">&quot;AFR_3&quot;</span>), <span class="at">eur =</span> <span class="fu">c</span>(<span class="st">&quot;EUR_1&quot;</span>, <span class="st">&quot;EUR_2&quot;</span>)))</span></code></pre></div>
<pre><code>#&gt; # A tibble: 1 × 3
#&gt;   x     y        Fst
#&gt;   &lt;chr&gt; &lt;chr&gt;  &lt;dbl&gt;
#&gt; 1 afr   eur   0.0495</code></pre>
<p>In case a non-named list of sample sets was provided, set names are
generated automatically:</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb70-1"><a href="#cb70-1" tabindex="-1"></a><span class="fu">ts_fst</span>(ts, <span class="at">sample_sets =</span> <span class="fu">list</span>(<span class="fu">c</span>(<span class="st">&quot;AFR_1&quot;</span>, <span class="st">&quot;AFR_2&quot;</span>, <span class="st">&quot;AFR_3&quot;</span>), <span class="fu">c</span>(<span class="st">&quot;EUR_1&quot;</span>, <span class="st">&quot;EUR_2&quot;</span>)))</span></code></pre></div>
<pre><code>#&gt; # A tibble: 1 × 3
#&gt;   x     y        Fst
#&gt;   &lt;chr&gt; &lt;chr&gt;  &lt;dbl&gt;
#&gt; 1 set_1 set_2 0.0495</code></pre>
<p>Of course, this is much less readable and we encourage you to name
the sample sets appropriately.</p>
<p>In case more than two sample sets are specified, all pairwise
statistics are computed:</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb72-1"><a href="#cb72-1" tabindex="-1"></a><span class="fu">ts_fst</span>(ts, <span class="at">sample_sets =</span> <span class="fu">list</span>(<span class="at">afr =</span> <span class="fu">c</span>(<span class="st">&quot;AFR_1&quot;</span>, <span class="st">&quot;AFR_2&quot;</span>, <span class="st">&quot;AFR_3&quot;</span>),</span>
<span id="cb72-2"><a href="#cb72-2" tabindex="-1"></a>                              <span class="at">eur =</span> <span class="fu">c</span>(<span class="st">&quot;EUR_1&quot;</span>, <span class="st">&quot;EUR_2&quot;</span>),</span>
<span id="cb72-3"><a href="#cb72-3" tabindex="-1"></a>                              <span class="at">nea =</span> <span class="fu">c</span>(<span class="st">&quot;NEA_1&quot;</span>, <span class="st">&quot;NEA_2&quot;</span>)))</span></code></pre></div>
<pre><code>#&gt; # A tibble: 3 × 3
#&gt;   x     y        Fst
#&gt;   &lt;chr&gt; &lt;chr&gt;  &lt;dbl&gt;
#&gt; 1 afr   eur   0.0495
#&gt; 2 afr   nea   0.555 
#&gt; 3 eur   nea   0.541</code></pre>
<p>As with many other statistics implemented by <a href="https://tskit.dev/tskit/docs/stable/python-api.html"><em>tskit</em></a><em>,</em>
<code>ts_fst()</code> accepts a <code>windows</code> argument,
specifying the breakpoints between windows. In this case, the
<code>Fst</code> column in the resulting data frame is a so called
“list-column”, with each item in the column being a vector of <span class="math inline">\(F_{st}\)</span> values, one per each window.
List-columns can be a little confusing for new R users, but we highly
encourage you to get used to them as they allow extremely concise and
elegant handling of structured data within normal data frames (you can
start with <a href="https://jennybc.github.io/purrr-tutorial/ls13_list-columns.html">this</a>
introduction).</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb74-1"><a href="#cb74-1" tabindex="-1"></a><span class="co"># define breakpoints between 20 windows</span></span>
<span id="cb74-2"><a href="#cb74-2" tabindex="-1"></a>breakpoints <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="dv">0</span>, ts<span class="sc">$</span>sequence_length, <span class="at">length.out =</span> <span class="dv">21</span>)</span>
<span id="cb74-3"><a href="#cb74-3" tabindex="-1"></a></span>
<span id="cb74-4"><a href="#cb74-4" tabindex="-1"></a><span class="co"># calculate window-based Fst statistic</span></span>
<span id="cb74-5"><a href="#cb74-5" tabindex="-1"></a>win_fst <span class="ot">&lt;-</span> <span class="fu">ts_fst</span>(</span>
<span id="cb74-6"><a href="#cb74-6" tabindex="-1"></a>  ts, <span class="at">windows =</span> breakpoints,</span>
<span id="cb74-7"><a href="#cb74-7" tabindex="-1"></a>  <span class="at">sample_sets =</span> <span class="fu">list</span>(<span class="at">afr =</span> <span class="fu">c</span>(<span class="st">&quot;AFR_1&quot;</span>, <span class="st">&quot;AFR_2&quot;</span>, <span class="st">&quot;AFR_3&quot;</span>),</span>
<span id="cb74-8"><a href="#cb74-8" tabindex="-1"></a>                     <span class="at">eur =</span> <span class="fu">c</span>(<span class="st">&quot;EUR_1&quot;</span>, <span class="st">&quot;EUR_2&quot;</span>),</span>
<span id="cb74-9"><a href="#cb74-9" tabindex="-1"></a>                     <span class="at">nea =</span> <span class="fu">c</span>(<span class="st">&quot;NEA_1&quot;</span>, <span class="st">&quot;NEA_2&quot;</span>))</span>
<span id="cb74-10"><a href="#cb74-10" tabindex="-1"></a>)</span>
<span id="cb74-11"><a href="#cb74-11" tabindex="-1"></a></span>
<span id="cb74-12"><a href="#cb74-12" tabindex="-1"></a><span class="co"># we get 20 values for each parwise calculation</span></span>
<span id="cb74-13"><a href="#cb74-13" tabindex="-1"></a>win_fst</span></code></pre></div>
<pre><code>#&gt; # A tibble: 3 × 3
#&gt;   x     y     Fst         
#&gt;   &lt;chr&gt; &lt;chr&gt; &lt;named list&gt;
#&gt; 1 afr   eur   &lt;dbl [20]&gt;  
#&gt; 2 afr   nea   &lt;dbl [20]&gt;  
#&gt; 3 eur   nea   &lt;dbl [20]&gt;</code></pre>
<p>For instance, here are window-based <span class="math inline">\(F_st\)</span> values for the
<code>afr-vs-eur</code> calculation (first row of the table above):</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb76-1"><a href="#cb76-1" tabindex="-1"></a>win_fst[<span class="dv">1</span>, ]<span class="sc">$</span>Fst</span></code></pre></div>
<pre><code>#&gt; $`1`
#&gt;  [1] 0.04241163 0.06803338 0.04129167 0.06031210 0.05516414 0.03059425
#&gt;  [7] 0.03320629 0.05755971 0.05271680 0.04346970 0.03659568 0.05432308
#&gt; [13] 0.05913699 0.05905198 0.04119386 0.04389669 0.05086942 0.06181126
#&gt; [19] 0.03929837 0.06373172</code></pre>
</div>
<div id="tajimas-d" class="section level3">
<h3>Tajima’s <span class="math inline">\(D\)</span></h3>
<p>The function <code>ts_tajima()</code> has nearly the same interface
as <code>ts_fst()</code> shown above.</p>
<p>If a non-window version is to be calculated, we get a single
genome-wide values for each sample set (named or non-named list of
character vectors with individual names):</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb78-1"><a href="#cb78-1" tabindex="-1"></a><span class="fu">ts_tajima</span>(ts, <span class="fu">list</span>(<span class="at">afr =</span> <span class="fu">c</span>(<span class="st">&quot;AFR_1&quot;</span>, <span class="st">&quot;AFR_2&quot;</span>, <span class="st">&quot;AFR_3&quot;</span>), <span class="at">eur =</span> <span class="fu">c</span>(<span class="st">&quot;EUR_1&quot;</span>, <span class="st">&quot;EUR_2&quot;</span>)))</span></code></pre></div>
<pre><code>#&gt; # A tibble: 2 × 2
#&gt;   set           D
#&gt;   &lt;chr&gt;     &lt;dbl&gt;
#&gt; 1 afr   -0.000701
#&gt; 2 eur   -0.0140</code></pre>
<p>For window-based version, the function returns the <code>D</code>
column as a list column of vectors with <span class="math inline">\(i\)</span>-th element being the Tajima’s D value
for the <span class="math inline">\(i\)</span>-th window:</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb80-1"><a href="#cb80-1" tabindex="-1"></a><span class="fu">ts_tajima</span>(ts, <span class="fu">list</span>(<span class="at">afr =</span> <span class="fu">c</span>(<span class="st">&quot;AFR_1&quot;</span>, <span class="st">&quot;AFR_2&quot;</span>), <span class="at">eur =</span> <span class="fu">c</span>(<span class="st">&quot;EUR_1&quot;</span>, <span class="st">&quot;EUR_2&quot;</span>)), <span class="at">windows =</span> breakpoints)</span></code></pre></div>
<pre><code>#&gt; # A tibble: 2 × 2
#&gt;   set   D           
#&gt;   &lt;chr&gt; &lt;named list&gt;
#&gt; 1 afr   &lt;dbl [20]&gt;  
#&gt; 2 eur   &lt;dbl [20]&gt;</code></pre>
</div>
<div id="diversity" class="section level3">
<h3>Diversity</h3>
<p>We can calculate diversity within given groups of individuals with
the function <code>ts_diversity()</code>. For instance, even in our
extremely simplified example, we would expect the highest levels of
diversity in Africans, followed by Europeans, Neanderthals and the
“degenerate” single individual outgroup “chimpanzee”. Is this true?
Let’s find out.</p>
<p>First we extract individuals from all populations, creating a list of
character vectors for each group (which is what functions such as
<code>ts_diversity()</code> expects as an input):</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb82-1"><a href="#cb82-1" tabindex="-1"></a><span class="co"># get sampled individuals from all populations</span></span>
<span id="cb82-2"><a href="#cb82-2" tabindex="-1"></a>sample_sets <span class="ot">&lt;-</span> <span class="fu">ts_samples</span>(ts) <span class="sc">%&gt;%</span></span>
<span id="cb82-3"><a href="#cb82-3" tabindex="-1"></a>  <span class="fu">split</span>(., .<span class="sc">$</span>pop) <span class="sc">%&gt;%</span></span>
<span id="cb82-4"><a href="#cb82-4" tabindex="-1"></a>  <span class="fu">lapply</span>(<span class="cf">function</span>(pop) pop<span class="sc">$</span>name)</span>
<span id="cb82-5"><a href="#cb82-5" tabindex="-1"></a></span>
<span id="cb82-6"><a href="#cb82-6" tabindex="-1"></a>sample_sets</span></code></pre></div>
<pre><code>#&gt; $AFR
#&gt; [1] &quot;AFR_1&quot; &quot;AFR_2&quot; &quot;AFR_3&quot; &quot;AFR_4&quot; &quot;AFR_5&quot;
#&gt; 
#&gt; $CH
#&gt; [1] &quot;CH_1&quot;
#&gt; 
#&gt; $EUR
#&gt;  [1] &quot;EUR_1&quot;  &quot;EUR_2&quot;  &quot;EUR_3&quot;  &quot;EUR_4&quot;  &quot;EUR_5&quot;  &quot;EUR_6&quot;  &quot;EUR_7&quot;  &quot;EUR_8&quot; 
#&gt;  [9] &quot;EUR_9&quot;  &quot;EUR_10&quot; &quot;EUR_11&quot; &quot;EUR_12&quot; &quot;EUR_13&quot; &quot;EUR_14&quot; &quot;EUR_15&quot; &quot;EUR_16&quot;
#&gt; [17] &quot;EUR_17&quot; &quot;EUR_18&quot; &quot;EUR_19&quot; &quot;EUR_20&quot; &quot;EUR_21&quot; &quot;EUR_22&quot; &quot;EUR_23&quot; &quot;EUR_24&quot;
#&gt; [25] &quot;EUR_25&quot; &quot;EUR_27&quot; &quot;EUR_26&quot; &quot;EUR_28&quot; &quot;EUR_29&quot; &quot;EUR_30&quot; &quot;EUR_31&quot; &quot;EUR_32&quot;
#&gt; [33] &quot;EUR_33&quot; &quot;EUR_34&quot; &quot;EUR_35&quot; &quot;EUR_36&quot; &quot;EUR_37&quot; &quot;EUR_38&quot; &quot;EUR_39&quot; &quot;EUR_40&quot;
#&gt; [41] &quot;EUR_41&quot; &quot;EUR_42&quot; &quot;EUR_43&quot; &quot;EUR_44&quot; &quot;EUR_45&quot; &quot;EUR_46&quot; &quot;EUR_47&quot; &quot;EUR_48&quot;
#&gt; [49] &quot;EUR_49&quot; &quot;EUR_50&quot;
#&gt; 
#&gt; $NEA
#&gt; [1] &quot;NEA_1&quot; &quot;NEA_2&quot;</code></pre>
<p>Now we can calculate diversity in each population and sort the
results in an increasing order of diversity:</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb84-1"><a href="#cb84-1" tabindex="-1"></a><span class="fu">ts_diversity</span>(ts, sample_sets) <span class="sc">%&gt;%</span> dplyr<span class="sc">::</span><span class="fu">arrange</span>(diversity)</span></code></pre></div>
<pre><code>#&gt; # A tibble: 4 × 2
#&gt;   set   diversity
#&gt;   &lt;chr&gt;     &lt;dbl&gt;
#&gt; 1 CH    0.0000431
#&gt; 2 NEA   0.0000455
#&gt; 3 EUR   0.000394 
#&gt; 4 AFR   0.000400</code></pre>
<p>Great! This matches our expectations. We simulated chimp “population”
as only one individual, so we expect essentially no diversity after
millions of years of evolution.</p>
</div>
<div id="divergence" class="section level3">
<h3>Divergence</h3>
<p>We can calculate pairwise divergence between groups of individuals
using the function <code>ts_divergence()</code>. Given our model, we
would expect the lowest divergence between the two modern human groups
<code>AFR</code> and <code>EUR</code>, then between Neanderthals and the
two modern humans, and all three groups (<code>AFR</code>,
<code>EUR</code> and <code>NEA</code>) should have equal, much deeper
divergence from the outgroup chimpanzee <code>CH</code>.</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb86-1"><a href="#cb86-1" tabindex="-1"></a><span class="fu">ts_divergence</span>(ts, sample_sets) <span class="sc">%&gt;%</span> <span class="fu">arrange</span>(divergence)</span></code></pre></div>
<pre><code>#&gt; # A tibble: 6 × 3
#&gt;   x     y     divergence
#&gt;   &lt;chr&gt; &lt;chr&gt;      &lt;dbl&gt;
#&gt; 1 AFR   EUR     0.000449
#&gt; 2 EUR   NEA     0.000757
#&gt; 3 AFR   NEA     0.000780
#&gt; 4 CH    NEA     0.00401 
#&gt; 5 CH    EUR     0.00402 
#&gt; 6 AFR   CH      0.00402</code></pre>
<p>After sorting the table based on the value in the divergence column,
we can see the results fit our expectations.</p>
</div>
</div>
<div id="more-information" class="section level2">
<h2>More information</h2>
<p>These were only a couple of examples of statistical functions
implemented in <em>tskit</em> for which we provide a native R interface
in <em>slendr</em>. You can find more tree-sequence statistics in the <a href="../reference/index.html#section-tree-sequence-statistics">reference
manual</a> on the project website. Not <a href="https://tskit.dev/tskit/docs/stable/stats.html#available-statistics">all
statistics</a> from the <em>tskit</em> library are implemented, but we
intend to expand the selection provided by <em>slendr</em> in the near
future. If there is some functionality that you would like to use in
your project missing in <em>slendr</em>, please don’t hesitate to let us
now by creating an issue on our <a href="https://github.com/bodkan/slendr/issues">GitHub page</a>.</p>
<p>Finally, if you would like to see more examples of <em>tskit</em>
interface in action, take a look at the vignette which describes <a href="https://www.slendr.net/articles/vignette-07-backends.html">switching
between the SLiM and <em>msprime</em> back ends</a> of the
<em>slendr</em> package.</p>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
